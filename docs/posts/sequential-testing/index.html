<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Sequential Testing Guide | Nikita Podlozhniy</title>
<meta name="keywords" content="">
<meta name="description" content="How GST is often misinterpreted and why its genuine version is way better than AVI?">
<meta name="author" content="Nikita Podlozhniy">
<link rel="canonical" href="https://npodlozhniy.github.io/posts/sequential-testing/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.js" onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://npodlozhniy.github.io/favicons/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://npodlozhniy.github.io/favicons/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://npodlozhniy.github.io/favicons/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://npodlozhniy.github.io/favicons/apple-touch-icon.png">
<link rel="mask-icon" href="https://npodlozhniy.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://npodlozhniy.github.io/posts/sequential-testing/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"
    onload="renderMathInElement(document.body, 
    {
              delimiters: [
                  {left: '$$', right: '$$', display: true},
                  {left: '\\[', right: '\\]', display: true},
                  {left: '$', right: '$', display: false},
                  {left: '\\(', right: '\\)', display: false}
              ]
          }
    );"></script>



<script src="https://cdn.plot.ly/plotly-2.11.1.min.js"></script>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-ESWD18X008"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-ESWD18X008', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="Sequential Testing Guide" />
<meta property="og:description" content="How GST is often misinterpreted and why its genuine version is way better than AVI?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://npodlozhniy.github.io/posts/sequential-testing/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-12-25T00:00:00+00:00" />
<meta property="article:modified_time" content="2024-12-25T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Sequential Testing Guide"/>
<meta name="twitter:description" content="How GST is often misinterpreted and why its genuine version is way better than AVI?"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://npodlozhniy.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Sequential Testing Guide",
      "item": "https://npodlozhniy.github.io/posts/sequential-testing/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Sequential Testing Guide",
  "name": "Sequential Testing Guide",
  "description": "How GST is often misinterpreted and why its genuine version is way better than AVI?",
  "keywords": [
    
  ],
  "articleBody": "\rIntro Sequential testing designs have gained significant popularity in AB testing due to their ability to potentially reduce the required sample size and experiment duration while maintaining statistical correctness. This approach allows for interim analyses of data as it accumulates, offering the possibility to stop the experiment early if a clear winner emerges, or if it becomes evident that the treatment effect is insufficient to justify continuing (stop for futility)\nIn this article, we shift our focus away from the theoretical intricacies of the problem and instead delve into a comprehensive exploration of available sequential testing solutions. We will discuss their implementations, compare their performance, and highlight their strengths and weaknesses. By examining these practical aspects, we aim to equip practitioners with the knowledge to make informed decisions when incorporating sequential testing into their AB testing workflows.\nApproach Among the variety of sequential testing designs, there are basically two broad families of algorithms: Group Sequential Testing (GST) and Always Valid Inference (AVI). These methods represent distinct philosophies in their handling of interim analyses and experiment stopping criteria..\nGST works with predefined interim analysis points and utilizes predetermined stopping boundaries to decide whether to stop the experiment at each stage.\nAVI allows continuous monitoring and providing valid confident intervals at any point, making it adaptable for uncertain experiment duration or analysis frequencies.\nThis article primarily focuses on these two techniques, providing an overview of their methodologies and practical implications.\nGroup Sequential Testing For group sequential testing there is a handy package in R and I will show below how to use it, although for those, who prefers Python due to any reason, whether it is the absence of an interpreter, infrastructure limitations or just personal preferences, there is no direct and popular alternative package, so I had to write it on my own and now ready to share with you after careful testing and benchmarking.\nGST in R If you‚Äôre ready to use R library there are two options: use R runtime directly or through rpy2 Python package. Both options are available for example within Google Colab environment.\nHere is an instance of rpy2 package inference within Colab Notebook, when you run R code from the Python interpreter using an extension.\niPython Notebook %load_ext rpy2.ipython %%R R.version.string install.packages(\"ldbounds\") %%R library(ldbounds) ldBounds(t=seq(1/4, 1, 1/4), iuse=3, phi=1, alpha=0.05, sides=1)$upper.bounds Python File The code above may be rewritten into a simple .py file as follows, you are to use created stats package as a plain Python package thereafter.\n‚ö†Ô∏è Caution\nIt will not work in Google Colab for instance, as it requires R installed in addition to Python.\nCode\rimport rpy2.robjects.packages as rpackages from rpy2.robjects.vectors import StrVector utils = rpackages.importr('utils') # select a mirror for R packages utils.chooseCRANmirror(ind=1) # R package names packnames = ('ldbounds') # Selectively install what needs to be install. names_to_install = [ package for package in packnames if not rpackages.isinstalled(package) ] if len(names_to_install) \u003e 0: utils.install_packages(StrVector(names_to_install)) stats = rpackages.importr('ldbounds') If R is not your cup of tea, or simply there is no option to run it within the scope of the production infrastructure, what is the most common limitation by the way, now begins exactly what you need.\nGST in Python There is quite popular incorrect implementation powered by Zalando expan\nIt works without probability integration and mistakenly leverage alpha spending function as a critical value at each step, it‚Äôs common misunderstanding about alpha-spending function approach, there are number of implementations that do it the exact same wrong way, and even world‚Äôs leading publication for data science, according to their own definition, makes the same mistakes, for instance: Understanding of Group Sequential Testing published in Towards Data Science\nAs it will shown below that approach is statistically incorrect and so it‚Äôs highly recommended to avoid it.\nInstead I propose you to apply the new library seqabpy that is powerful and accurate and what is more important implemented according to the original papers Interim analysis: The alpha spending function approach by K. K. Gordon Lan and David L. DeMets (1983) and further related publications, you may find them all mentioned in Reference lines of the methods‚Äô docstrings, let‚Äôs take a look at the functionality\nCode\rimport numpy as np import pandas as pd from scipy.stats import norm seabpy provides Group Sequential Testing in a separate module - gatsby which name is an anagram of Group Sequential AB Testing in PYthon and below it‚Äôs shown why gatsby is often referred as ¬´The Great Gatsby¬ª\n#!pip install seqabpy from seqabpy import gatsby Lan-DeMets calculate_sequential_bounds function implements rigorous approach to calculate confidence bounds in one-sided GST. In addition to upper bounds, if beta is provided it calculates lower bounds to unlock the option of stopping the test for futility, maintaining provided Type II error rate. The algorithm is taken from the article Group sequential designs using both type I and type II error probability spending functions by Chang MN, Hwang I, Shih WJ. (1998)\ngatsby.calculate_sequential_bounds(np.linspace(1/10, 1, 10), alpha=0.05, beta=0.2) Sequential bounds algorithm to stop for futility converged to 0.00064 tolerance in 8 iterations using O'Brien-Fleming spending function.\r(array([-3.02102866, -1.41478896, -0.59632535, -0.05664366, 0.35069266,\r0.68203514, 0.96419224, 1.21185008, 1.43395402, 1.79496377]),\rarray([6.08789285, 4.22919942, 3.39632756, 2.90614903, 2.57897214,\r2.34174062, 2.15981329, 2.0146325 , 1.89528829, 1.79496377]))\rldBounds function returns the exact same numbers as R package and tailored to have similar interface, in both input and output.\nAs a subtle benefit it supports more spending functions, take a look at the docstring to know more details.\ngatsby.ldBounds(t=np.linspace(1/4, 1, 4), iuse=3, phi=1) {'time.points': array([0.25, 0.5 , 0.75, 1. ]),\r'alpha.spending': array([0.0125, 0.0125, 0.0125, 0.0125]),\r'overall.alpha': 0.05,\r'upper.bounds': array([2.24140273, 2.1251188 , 2.01870509, 1.92553052]),\r'nominal.alpha': array([0.0125 , 0.01678835, 0.02175894, 0.02708151])}\rIn case of calculation of upper bounds only the algorithm is faster, given that these boundaries shall be defined and fixed offline prior to the experiment start, it‚Äôs totally sensible performance, when in addition lower aka futility bounds are computed it takes more time\n%%time gatsby.ldBounds(t=np.linspace(1/10, 1, 10), alpha=0.1) CPU times: total: 7.73 s\rWall time: 7.75 s\r{'time.points': array([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1. ]),\r'alpha.spending': array([1.97703624e-07, 2.34868089e-04, 2.43757240e-03, 6.62960181e-03,\r1.07070137e-02, 1.37029812e-02, 1.55891351e-02, 1.66134835e-02,\r1.70337597e-02, 1.70513868e-02]),\r'overall.alpha': 0.10000000000000009,\r'upper.bounds': array([5.07115563, 3.4973068 , 2.79510152, 2.38848818, 2.11870064,\r1.92350461, 1.77394818, 1.65463799, 1.55659472, 1.47418673]),\r'nominal.alpha': array([1.97703624e-07, 2.34990500e-04, 2.59417098e-03, 8.45892623e-03,\r1.70578873e-02, 2.72083541e-02, 3.80358613e-02, 4.89989759e-02,\r5.97833696e-02, 7.02156613e-02])}\rAn example of less popular Haybittle-Peto spending function usage\ngatsby.ldBounds(t=np.linspace(1/4, 1, 4), iuse=5) {'time.points': array([0.25, 0.5 , 0.75, 1. ]),\r'alpha.spending': array([0.0013499, 0. , 0. , 0.0486501]),\r'overall.alpha': 0.05,\r'upper.bounds': array([3. , 3. , 3. , 1.63391418]),\r'nominal.alpha': array([0.0013499 , 0.0013499 , 0.0013499 , 0.05113844])}\rGST GST is the general function that accounts for various deviations in the experiment design, in other words if the peeking strategy is different the method adjusts the bounds to guarantee the valid statistical approach whenever it‚Äôs possible.\nIn particular it‚Äôs perfect to handle a few changed peeking points when the total number of peeking remains the same, and it works in a best possible way with under- and oversampling, in the latter case the procedure is not fully correct though as we will see in the simulations part.\nThe idea of implementation is taken from Group Sequential and Confirmatory Adaptive Designs in Clinical Trials by G. Wassmer and W. Brannath (2016)\nHere are a few examples, that shows how different peeking strategy affects the bounds:\ngatsby.ldBounds(t=np.array([0.3, 0.6, 1.0]), alpha=0.025) {'time.points': array([0.3, 0.6, 1. ]),\r'alpha.spending': array([4.27257874e-05, 3.76533752e-03, 2.11919367e-02]),\r'overall.alpha': 0.02499999999999991,\r'upper.bounds': array([3.92857254, 2.669972 , 1.98103004]),\r'nominal.alpha': array([4.27257874e-05, 3.79287858e-03, 2.37939526e-02])}\rin case of under-sampling the last upper bound is lower what reflects that all the rest of alpha volume is spent at this point in case of over-sampling the last upper bound is higher, what helps to control Type I error rate, after the expected sample size is reached gatsby.GST(actual=np.array([0.3, 0.6, 0.8]), expected=np.array([0.3, 0.6, 1]), alpha=0.025) array([3.92857254, 2.669972 , 1.96890411])\rgatsby.GST(actual=np.array([0.3, 0.6, 1.2]), expected=np.array([0.3, 0.6, 1]), alpha=0.025) array([3.92857254, 2.669972 , 1.98949242])\rUnder- and over- sampling may also happen in a more natural way, when a few peeking points are added or removed\ngatsby.ldBounds(t=np.array([0.3, 0.6, 0.8, 1.0]), alpha=0.025) {'time.points': array([0.3, 0.6, 0.8, 1. ]),\r'alpha.spending': array([4.27257874e-05, 3.76533752e-03, 8.40372704e-03, 1.27882097e-02]),\r'overall.alpha': 0.02499999999999991,\r'upper.bounds': array([3.92857254, 2.669972 , 2.28886308, 2.03074404]),\r'nominal.alpha': array([4.27257874e-05, 3.79287858e-03, 1.10436544e-02, 2.11404831e-02])}\rgatsby.GST(actual=np.array([0.3, 0.6, 0.8]), expected=np.array([0.3, 0.6, 0.8, 1]), alpha=0.025) array([3.92857254, 2.669972 , 2.15083427])\rgatsby.GST(actual=np.array([0.3, 0.6, 1, 1.2]), expected=np.array([0.3, 0.6, 1]), alpha=0.025) array([3.92857254, 2.669972 , 1.98102292, 2.0375539 ])\rGST also supports int as an input, if peeking point are distributed uniformly it‚Äôs what you should use in sake of convenience\ngatsby.GST(7, 7) array([5.05481268, 3.48557771, 2.78550934, 2.38021304, 2.1113425 ,\r1.9168349 , 1.76778516])\rWhile the method comes handy in most of scenarios, it doesn‚Äôt support all the possible deviations: the beginning of the expected and actual peeking strategies must be the same: so it‚Äôs either over- or under- sampling or the change in peeking points when their number remains equal\nNeedless to say that the application of GST and other functions mentioned above apparently is not limited to one-sided hypotheses, in order to test two-sided alternative: just set $\\alpha$ to half of the value, like 0.025 if you want to challenge two-sided hypothesis at 0.95 confidence level, and define lower bounds symmetrically about zero, so they would be the same in absolute values, but negative.\ngatsby.GST(actual=np.array([0.3, 0.6, 0.9, 1.2]), expected=np.array([0.3, 0.6, 0.8, 1]), alpha=0.025) # the following will not work # gatsby.GST(actual=np.array([0.3, 0.6]), expected=np.array([0.8, 1])) # gatsby.GST( # actual=np.array([0.3, 0.5, 0.6, 0.7, 0.8, 0.9, 1]), # expected=np.array([0.3, 0.6, 0.8, 1]) # ) array([3.92857254, 2.669972 , 2.30467653, 2.05129976])\rAlways Valid Inference While AVI is becoming increasingly popular in the field, bypassing GST, it‚Äôs worth noting that there are currently no widely adopted, comprehensive Python or R packages that focus solely on this approach.\nThere is one recent package savvi appeared this year, but it‚Äôs still in v0.. version and have not been yet fully acknowledged by the community. What is more it focuses only on the publications of Lindon et al.¬†from 2022 and 2024, while there are other notable authors like Zhao et al. and Howard et al. whose approach will be challenged in addition to Lindon‚Äôs work\nfrom seqabpy import gavi seqabpy provides Always Valid Inference functionality in gavi module where as of now, AlwaysValidInference is a main class that implements confidence intervals valid at any point. While intervals and namely their continuous comparison to the current z-score provides the apparatus that is just enough for practical decisions, p-values are to be released later as well, to complete experiment analysis picture.\nAlwaysValidInference an array of sample sizes when the peeking happens along with the metric variance and the result point difference. Multiple supported properties comprise different algorithms (the detailed description may be found in each docsrting) that return a boolean array indicating whether the null hypothesis is rejected in favour of one- or two- sided alternative for each size.\navi = gavi.AlwaysValidInference(size=np.arange(10, 100, 10), sigma2=1, estimate=1) GAVI is the method proposed by Howard et al.¬†and widely adopted in tech by Eppo\navi.GAVI(50) array([False, True, True, True, True, True, True, True, True])\rmSPRT is the approach proposed by M. Lindon in his article and is leveraged by Netflix\navi.mSPRT(0.08) array([False, False, True, True, True, True, True, True, True])\rStatSig_SPRT is the variation proposed by Zhao et al.¬†and as it comes from the name used currently by StatSig\navi.StatSig_SPRT() array([False, True, True, True, True, True, True, True, True])\rThe last and, this time, indeed least heavily criticized statsig_alpha_corrected_v1 approach, which was their first attempt to furnish their platform with a sequential testing framework. It‚Äôs mainly added for the reference to show how sequential testing must not work like\navi.statsig_alpha_corrected_v1(100) array([False, False, False, True, True, True, True, True, True])\rSimulations For those who have visited my blog before, there is nothing new in how we will conduct testing, it is good old Monte Carlo. For more details checkout my previous posts like Dunnett‚Äôs Correction for ABC testing\nWe will measure False and True positive rates for two kinds of the target metric: a continuous variable and a conversion. Furthermore we will learn how tolerant are different methods to under- and over- sampling.\nCode\r# Global simulation settings N = 500 alpha = 0.05 n_iterations = 100_000 def stops_at(is_significant: np.ndarray, sample_size: np.ndarray) -\u003e int: \"\"\" Determines the stopping sample size. This function identifies the first instance where the input condition is True and returns the corresponding sample size. Args: is_significant: A boolean array of the stop condition for each size sample_size: An array of sample sizes. Returns: The stopping sample size. Example: \u003e\u003e\u003e detN([False, False, True, True], [50, 100, 150, 200]) 150 \"\"\" if len(is_significant) != len(sample_size): raise ValueError(\"Input arrays must have the same length.\") w = np.where(is_significant)[0] return None if len(w) == 0 else sample_size[w[0]] One thing about GST is that incredible freedom in spending function choice what makes it possible to experiment and find the best fit for your data. For demonstration purposes I suggest using Kim-DeMets spending function with different values of the power $\\phi$: the higher $\\phi$ the more strict the function is at the beginning of the experiment.\nCode\rgst_linear = gatsby.GST(actual=10, expected=10, iuse=3, phi=1, alpha=alpha) gst_quadratic = gatsby.GST(actual=10, expected=10, iuse=3, phi=2, alpha=alpha) gst_cubic = gatsby.GST(actual=10, expected=10, iuse=3, phi=3, alpha=alpha) You can play around the trade-off: would you like to spend more $\\alpha$ at the start, detecting faster if there are greater uplifts in you experiment group or to preserve the major part of alpha until the end keeping maximum power to reject the hypothesis when the expected sample size is reached.\nüí° Tip\nIf the title or the legend items are not visible to you - double click to one of legend items and it will make the chart rendered properly. It may happen due to LaTeX usage.\nCode\rimport plotly.express as px import plotly.graph_objs as go def hex2rgba(hex, alpha): \"\"\" Convert plotly hex colors to rgb and enables transparency adjustment \"\"\" col_hex = hex.lstrip('#') col_rgb = tuple(int(col_hex[i : i + 2], 16) for i in (0, 2, 4)) col_rgb += (alpha,) return 'rgba' + str(col_rgb) def get_new_color(colors): while True: for color in colors: yield color colors_list = px.colors.qualitative.Plotly rgba_colors = [hex2rgba(color, alpha=0.5) for color in colors_list] palette = get_new_color(rgba_colors) def add_chart(figure, data, title=None): x = np.arange(1, len(data) + 1) / len(data) color = next(palette) figure.add_trace( go.Scatter( name=title, x=x, y=data, mode='lines', line=dict(color=color, width=4, dash='solid'), hovertemplate=\"%{y:.3f}\" ), ) figure = go.Figure() add_chart(figure, gst_linear, r\"$\\text{Linear: } \\phi = 1$\") add_chart(figure, gst_quadratic, r\"$\\text{Quadratic: } \\phi = 2$\") add_chart(figure, gst_cubic, r\"$\\text{Cubic: } \\phi = 3$\") figure.update_xaxes( title_text=\"Peeking moments\" ) figure.update_layout( yaxis_title=\"Critical value for z-score\", title={ \"x\": 0.5, \"text\": r\"$\\text{Kim-DeMets spending function: } \\alpha \\cdot t^{\\phi} \\text{ differences}$\", }, hovermode=\"x\", template=\"plotly_dark\", ) figure.write_json(\"alpha-spending-functions-comparison.json\") figure.show() Expan Flaw Remember I promised to show, that expan way to determine boundaries is wrong, so here is a quick proof: the code is taken without changes from their GitHub: zalando/expan/early_stopping\nCode\rfrom statsmodels.stats.proportion import proportion_confint def sample_size(x): \"\"\" Calculates valid sample size given the data. :param x: sample to calculate the sample size :type x: pd.Series or list (array-like) :return: sample size of the sample excluding nans :rtype: int \"\"\" # cast into a dummy numpy array to infer the dtype x_as_array = np.array(x) if np.issubdtype(x_as_array.dtype, np.number): _x = np.array(x, dtype=float) x_nan = np.isnan(_x).sum() # assuming categorical sample elif isinstance(x, pd.core.series.Series): x_nan = x.str.contains('NA').sum() else: x_nan = list(x).count('NA') return int(len(x) - x_nan) def obrien_fleming(information_fraction, alpha=0.05): \"\"\" Calculate an approximation of the O'Brien-Fleming alpha spending function. :param information_fraction: share of the information amount at the point of evaluation, e.g. the share of the maximum sample size :type information_fraction: float :param alpha: type-I error rate :type alpha: float :return: redistributed alpha value at the time point with the given information fraction :rtype: float \"\"\" return (1 - norm.cdf(norm.ppf(1 - alpha / 2) / np.sqrt(information_fraction))) * 2 def group_sequential(x, y, spending_function='obrien_fleming', estimated_sample_size=None, alpha=0.05, cap=8): \"\"\" Group sequential method to determine whether to stop early. :param x: sample of a treatment group :type x: pd.Series or array-like :param y: sample of a control group :type y: pd.Series or array-like :param spending_function: name of the alpha spending function, currently supports only 'obrien_fleming'. :type spending_function: str :param estimated_sample_size: sample size to be achieved towards the end of experiment :type estimated_sample_size: int :param alpha: type-I error rate :type alpha: float :param cap: upper bound of the adapted z-score :type cap: int :return: results of type EarlyStoppingTestStatistics :rtype: EarlyStoppingTestStatistics \"\"\" # Coercing missing values to right format _x = np.array(x, dtype=float) _y = np.array(y, dtype=float) n_x = sample_size(_x) n_y = sample_size(_y) if not estimated_sample_size: information_fraction = 1.0 else: information_fraction = min(1.0, (n_x + n_y) / estimated_sample_size) # alpha spending function if spending_function in ('obrien_fleming'): func = eval(spending_function) else: raise NotImplementedError alpha_new = func(information_fraction, alpha=alpha) # calculate the z-score bound bound = norm.ppf(1 - alpha_new / 2) # replace potential inf with an upper bound if bound == np.inf: bound = cap mu_x = np.nanmean(_x) mu_y = np.nanmean(_y) sigma_x = np.nanstd(_x) sigma_y = np.nanstd(_y) z = (mu_x - mu_y) / np.sqrt(sigma_x ** 2 / n_x + sigma_y ** 2 / n_y) if z \u003e bound or z \u003c -bound: stop = True else: stop = False return stop fpr = 0 for r in range(n_iterations): x = np.random.normal(1, 1, N) y = np.random.normal(1, 1, N) for current_size in np.linspace(N/10, N, 10).astype(int): stopping = group_sequential(x[:current_size], y[:current_size], estimated_sample_size=2*N, alpha=0.05) if stopping: fpr += 1 break l, r = proportion_confint(count=fpr, nobs=n_iterations, alpha=0.10, method='wilson') print(f\"false positives: {fpr/n_iterations:.3f} ¬± {(r - l) / 2:.3f} is significantly higher than {alpha}\") So, as was said above, it doesn‚Äôt control FPR as it should according to Group Sequential Testing problem design and hence this myth of the direct application of alpha spending function have to be dispelled: it doesn‚Äôt work this way and further you will see that it‚Äôs not much better than custom ad-hoc corrections.\n‚ö†Ô∏è Warning\nPlease, do not use expan for sequential testing as their implementation is wrong.\nMonte Carlo Code\rfrom collections import defaultdict def monte_carlo( metric: str=\"normal\", sampling: str=\"accurate\", effect_size: float=0.10, aa_test: bool=True, N: int = N, ) -\u003e pd.DataFrame: result = defaultdict(list) eff = 0 if aa_test else effect_size if metric == \"normal\": mu, sigma = 1, 1 else: p = 0.10 sigma = (p * (1 - p)) ** 0.5 # for bernoulli rv sigma is less than for normal # so it's better to increase N to get similar power N *= int((sigma / p) ** 2) for _ in range(n_iterations): if metric == \"normal\": x = np.random.normal(mu, sigma, N) y = np.random.normal(mu+eff, sigma, N) else: x = np.random.choice(a=[0, 1], size=N, replace=True, p=[1 - p, p]) y = np.random.choice(a=[0, 1], size=N, replace=True, p=[1 - p*(1+eff), p*(1+eff)]) size = np.arange(1, N + 1) diff = (np.cumsum(y) / size) - (np.cumsum(x) / size) test = gavi.AlwaysValidInference(size=size, sigma2=sigma**2, estimate=diff, alpha=alpha) itermittent_analyses = np.linspace(N/10, N, 10).astype(int) - 1 z_score = diff[itermittent_analyses] / np.sqrt(2 * sigma ** 2 / size[itermittent_analyses]) result['No_Seq'].append(N if z_score[-1] \u003e norm.ppf(1 - alpha) else None) if sampling == \"accurate\": result['GAVI'].append(stops_at(test.GAVI(), size)) result['mSPRT'].append(stops_at(test.mSPRT(), size)) result['StatSig_SPRT'].append(stops_at(test.StatSig_SPRT(), size)) result['StatSig_v1'].append(stops_at(test.statsig_alpha_corrected_v1(), size)) result['GST_linear'].append(stops_at(z_score \u003e gst_linear, size[itermittent_analyses])) result['GST_quadratic'].append(stops_at(z_score \u003e gst_quadratic, size[itermittent_analyses])) result['GST_cubic'].append(stops_at(z_score \u003e gst_cubic, size[itermittent_analyses])) elif sampling == \"undersampled\": result['GAVI'].append(stops_at(test.GAVI(phi=N*7/5), size)) # undersampling is the case, when the effect is larger than expected # so let's say effect ~ 7/5 times larger, 4 * (5/7)^2 ~ 2 result['mSPRT'].append(stops_at(test.mSPRT(phi=2 * sigma**2 / diff**2), size)) result['StatSig_SPRT'].append(stops_at(test.StatSig_SPRT(), size)) result['StatSig_v1'].append(stops_at(test.statsig_alpha_corrected_v1(N=N*7/5), size)) result['GST_linear'].append(stops_at(z_score \u003e gst_linear_undersampled, size[itermittent_analyses])) result['GST_quadratic'].append(stops_at(z_score \u003e gst_quadratic_undersampled, size[itermittent_analyses])) result['GST_cubic'].append(stops_at(z_score \u003e gst_cubic_undersampled, size[itermittent_analyses])) elif sampling == \"oversampled\": result['GAVI'].append(stops_at(test.GAVI(phi=N*7/10), size)) # oversmapling is the case, when the effect is lower than expected # so let's say effect ~ 7/10 times lower, 4 * (7/10)^2 ~ 8 result['mSPRT'].append(stops_at(test.mSPRT(phi=8 * sigma**2 / diff**2), size)) result['StatSig_SPRT'].append(stops_at(test.StatSig_SPRT(), size)) result['StatSig_v1'].append(stops_at(test.statsig_alpha_corrected_v1(N=N*7/10), size)) result['GST_linear'].append(stops_at(z_score \u003e gst_linear_oversampled, size[itermittent_analyses])) result['GST_quadratic'].append(stops_at(z_score \u003e gst_quadratic_oversampled, size[itermittent_analyses])) result['GST_cubic'].append(stops_at(z_score \u003e gst_cubic_oversampled, size[itermittent_analyses])) else: raise ValueError(\"Unknown sampling method\") # remove StatSig_v1 from Power comparison if not aa_test: result.pop('StatSig_v1') df = pd.DataFrame(result).agg([\"count\", \"median\"]).T.assign( PositiveRate=lambda x: (x[\"count\"] / n_iterations).round(3) ).assign( SampleSize=lambda x: x[\"median\"].astype(int) )[[\"PositiveRate\", \"SampleSize\"]] return df def plot_positive_rate( df: pd.DataFrame, aa_test: bool=True, sampling: str=None ): fig = go.Figure() if aa_test: error_const = round(3 * (alpha * (1 - alpha) / n_iterations) ** 0.5, 3) else: error_array = round(3 * (df[\"PositiveRate\"] * (1 - df[\"PositiveRate\"]) / n_iterations) ** 0.5, 3) fig.add_trace(go.Bar( x=df.index, y=df[\"PositiveRate\"], marker_color=next(palette), error_y=dict(type='constant', value=error_const) if aa_test else dict(type='data', array=error_array), )) if aa_test: fig.add_hline( y=0.05, line_dash=\"dot\", annotation_text=\"designed Type I error rate\", annotation_position=\"top right\" ) title = ( f\"{'Correctness' if aa_test else 'Power'} of\" f\"{' ' + sampling if sampling else ''} Sequential Testing Design\" ) fig.update_layout( yaxis_title=f\"{str(not aa_test)} Positive Rate\", title={ \"x\": 0.5, \"text\": title, }, hovermode=\"x\", template=\"plotly_dark\", ) fig.write_json(f\"{title.replace(' ', '-').lower()}.json\") fig.show() Continuous Variable As you can see for GST bounds are pre-calculated for the necessary intermittent analyses number that were expected to and in fact take place. We calculate bounds for 10 intermittent analyses scenario, in addition considering over- and under- sampling designs.\nCode\rgst_linear_undersampled = gatsby.GST(actual=10, expected=14, iuse=3, phi=1, alpha=alpha) gst_quadratic_undersampled = gatsby.GST(actual=10, expected=14, iuse=3, phi=2, alpha=alpha) gst_cubic_undersampled = gatsby.GST(actual=10, expected=14, iuse=3, phi=3, alpha=alpha) gst_linear_oversampled = gatsby.GST(actual=10, expected=7, iuse=3, phi=1, alpha=alpha) gst_quadratic_oversampled = gatsby.GST(actual=10, expected=7, iuse=3, phi=2, alpha=alpha) gst_cubic_oversampled = gatsby.GST(actual=10, expected=7, iuse=3, phi=3, alpha=alpha) False Positives Code\rdf = monte_carlo(aa_test=True) df PositiveRate SampleSize No_Seq 0.051 500 GAVI 0.018 221 mSPRT 0.048 38 StatSig_SPRT 0.026 43 StatSig_v1 0.074 421 GST_linear 0.051 300 GST_quadratic 0.050 400 GST_cubic 0.051 400 Code\rplot_positive_rate(df, aa_test=True) As it immediately comes clear: StatSig v1 correction was a flaw, all the other methods are targeting $\\alpha$ as needed, however out of AVI it‚Äôs only mSPRT that gives high enough level, the rest of them make fewer false positives what usually is a sign of lower statistical power, we will see it later.\nCode\rmonte_carlo(aa_test=True, sampling=\"undersampled\") PositiveRate SampleSize No_Seq 0.050 500 GAVI 0.014 253 mSPRT 0.043 38 StatSig_SPRT 0.026 41 StatSig_v1 0.015 451 GST_linear 0.047 350 GST_quadratic 0.046 500 GST_cubic 0.045 500 Code\rdf = monte_carlo(aa_test=True, sampling=\"oversampled\") df PositiveRate SampleSize No_Seq 0.051 500 GAVI 0.021 189 mSPRT 0.046 35 StatSig_SPRT 0.027 36 StatSig_v1 0.187 378 GST_linear 0.065 250 GST_quadratic 0.072 300 GST_cubic 0.077 350 Code\rplot_positive_rate(df, aa_test=True, sampling=\"oversampled\") Over-sampling is a tough cookie for GST, in such a case GST doesn‚Äôt work correctly, it inflates Type I error, so it‚Äôs important to note the difference here between AVI and GST, the latter one is not designed to handle over-sampling StatSig distinguished itself: their v1 version suffers more than any other method form both under- and over- sampling, while on the other flip their SPRT implementation is totally resistant to under- and over- sampling and if identifies the positive, it does it quickly, most likely it will be underpowered though. As of now mSPRT seems to be the best choice as it identifies the differences so fast and just a little less often than it should. True Positives It‚Äôs time to compare the power of different methods, I‚Äôm not going to consider StatSig Alpha corrected version anymore as it‚Äôs not a valid procedure\nCode\rdf = monte_carlo(aa_test=False) df PositiveRate SampleSize No_Seq 0.474 500 GAVI 0.222 285 mSPRT 0.268 202 StatSig_SPRT 0.188 230 GST_linear 0.409 300 GST_quadratic 0.445 350 GST_cubic 0.459 400 Code\rplot_positive_rate(df, aa_test=False) Code\rdf = monte_carlo(aa_test=False, sampling=\"undersampled\") df PositiveRate SampleSize No_Seq 0.478 500 GAVI 0.211 306 mSPRT 0.253 210 StatSig_SPRT 0.190 233 GST_linear 0.425 350 GST_quadratic 0.449 450 GST_cubic 0.455 500 Code\rplot_positive_rate(df, aa_test=False, sampling=\"undersampled\") Code\rmonte_carlo(aa_test=False, sampling=\"oversampled\") PositiveRate SampleSize No_Seq 0.476 500 GAVI 0.236 268 mSPRT 0.263 208 StatSig_SPRT 0.190 233 GST_linear 0.443 300 GST_quadratic 0.496 300 GST_cubic 0.519 350 So, as it comes from bar chart and tables:\nall AVI (including over-sampled options) are way weaker than even under-sampled GST, so power-wise GST is an unconditional winner it‚Äôs appealing that for under-sampled GST the power has just a subtle decline, and even then only for strict spending function (Cubic), providing an increase for permissive spending function (Linear) Although if AVI rejects null hypothesis it does quicker (the required Sample Size is smaller) than GST on average Conversion Rate In addition to continuous measure, let‚Äôs consider ratio variable, how the methods work with conversions\nFalse Positives Code\rdf = monte_carlo(aa_test=True, metric=\"choice\") df PositiveRate SampleSize No_Seq 0.050 4500 GAVI 0.018 1913 mSPRT 0.072 88 StatSig_SPRT 0.044 60 StatSig_v1 0.074 3796 GST_linear 0.050 2700 GST_quadratic 0.049 3600 GST_cubic 0.049 3600 Code\rplot_positive_rate(df, aa_test=True, sampling=\"ratio\") As you see, in addition to StatSig v1 Alpha Correction which is again an outsider, mSPRT approximation is not good enough for Bernoulli random variable, for conversions it‚Äôs another approach that shall be applied, savvi package might come handy here as it the main purpose the that library - to work with inhomogeneous Bernoulli or Poisson process. Alternatively, you may use sequential_p_value function from gavi module of seqabpy, it‚Äôs a valid procedure following the algorithm defined by M. Lindon and A. Malek in Anytime-Valid Inference For Multinomial Count Data (2022), could be a little less powerful though than savvi implementation that follows even more recent articles.\nCode\rexpected_probs = [0.5, 0.5] # it's an asymptotic algorithm, so only numerators are compared # assuming the denominators of convesrion are similar like in fair A/B test actual_counts = [156, 212] print(f\"AVI p-value for Conversion: {gavi.sequential_p_value(actual_counts, expected_probs):.3f}\") AVI p-value for Conversion: 0.075\rCode\rdf = monte_carlo(aa_test=True, metric=\"choice\", sampling=\"oversampled\") df PositiveRate SampleSize No_Seq 0.051 4500 GAVI 0.022 1620 mSPRT 0.069 85 StatSig_SPRT 0.045 61 StatSig_v1 0.189 3377 GST_linear 0.064 2250 GST_quadratic 0.072 2700 GST_cubic 0.076 3150 Code\rplot_positive_rate(df, aa_test=True, sampling=\"oversampled ratio\") This chart above is just to assure you, that for conversions over-sampled GST doesn‚Äôt work neither, I can‚Äôt help but prove that GST in oversampling design is a flaw, while yet much better than Statsig v1 Alpha Corrections.\nTrue Positives Let‚Äôs take a brief look at the power comparison for a couple different effect sizes\nCode\rdf = monte_carlo(aa_test=False, metric=\"choice\", effect_size=0.10) df PositiveRate SampleSize No_Seq 0.480 4500 GAVI 0.240 2482 mSPRT 0.310 1441 StatSig_SPRT 0.226 1702 GST_linear 0.420 2700 GST_quadratic 0.449 3150 GST_cubic 0.460 3600 Code\rplot_positive_rate(df, aa_test=False, sampling=\"ratio\") Code\rdf = monte_carlo(aa_test=False, metric=\"choice\", effect_size=0.2) df PositiveRate SampleSize No_Seq 0.930 4500 GAVI 0.767 2127 mSPRT 0.796 1593 StatSig_SPRT 0.718 1923 GST_linear 0.898 2250 GST_quadratic 0.915 2250 GST_cubic 0.921 2700 Code\rplot_positive_rate(df, aa_test=False, sampling=\"strong effect\") With the growing effect size the relative difference in power is getting lower, but you can check that with any kind of reasonable effect size, GST outperforms AVI and what is more even for conversion variable, where mSPRT method doesn‚Äôt really control Type I error rate, it‚Äôs less powerful than GST after all.\nConclusion Generally speaking, I‚Äôd rather say that GST is yet the best framework for sequential testing, despite all the recent publications on cutting-edge AVI variations.\nHowever, I have to make a clause: while AVI is noticeably less powerful, it‚Äôs perfect to work in a streaming manner for guardrail metrics, while GST is better for target metrics within you AB test.\nüí° Practical Tip\nCombining these methodologies you may set up robust Sequential Testing framework, gaining from both: quick detection of major deterioration in your product with AVI and reliable uplifts discoveries in your decisive metrics with the most powerful GST procedure.\nAnother important point is to be conscious about the choice of the specific version of the algorithms that you will use.\nFor instance running an under-sampled experiments where GST with strict alpha spending functions, like Cubic, applied is less preferable, under-sampling works better with permissive spending functions, as well as over-sampling with Cubic spending is worse as it inflates $\\alpha$ more.\nüí° General Rule\nThe more permissive spending function is the faster effect is identified, but the less power at the end of experiment is achieved, what is especially striking for less substantial effect sizes.\nRounding this extensive blog-post up, here are the recommendations on choosing the sequential testing framework wrapped up into a single decision tree:\n",
  "wordCount" : "4675",
  "inLanguage": "en",
  "datePublished": "2024-12-25T00:00:00Z",
  "dateModified": "2024-12-25T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Nikita Podlozhniy"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://npodlozhniy.github.io/posts/sequential-testing/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Nikita Podlozhniy",
    "logo": {
      "@type": "ImageObject",
      "url": "https://npodlozhniy.github.io/favicons/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://npodlozhniy.github.io/" accesskey="h" title="Nikita Podlozhniy (Alt + H)">Nikita Podlozhniy</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="https://npodlozhniy.github.io/ru/" title="Russian"
                            aria-label=":ru:">Ru</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://npodlozhniy.github.io/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://npodlozhniy.github.io/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://npodlozhniy.github.io/search" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://npodlozhniy.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://npodlozhniy.github.io/">Home</a>&nbsp;¬ª&nbsp;<a href="https://npodlozhniy.github.io/posts/">Posts</a></div>
    <h1 class="post-title">
      Sequential Testing Guide
    </h1>
    <div class="post-meta"><span title='2024-12-25 00:00:00 +0000 UTC'>December 25, 2024</span>&nbsp;¬∑&nbsp;22 min&nbsp;¬∑&nbsp;Nikita Podlozhniy

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#intro" aria-label="Intro">Intro</a></li>
                <li>
                    <a href="#approach" aria-label="Approach">Approach</a></li>
                <li>
                    <a href="#group-sequential-testing" aria-label="Group Sequential Testing">Group Sequential Testing</a><ul>
                        
                <li>
                    <a href="#gst-in-r" aria-label="GST in R">GST in R</a><ul>
                        
                <li>
                    <a href="#ipython-notebook" aria-label="iPython Notebook">iPython Notebook</a></li>
                <li>
                    <a href="#python-file" aria-label="Python File">Python File</a></li></ul>
                </li>
                <li>
                    <a href="#gst-in-python" aria-label="GST in Python">GST in Python</a><ul>
                        
                <li>
                    <a href="#lan-demets" aria-label="Lan-DeMets">Lan-DeMets</a></li>
                <li>
                    <a href="#gst" aria-label="GST">GST</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#always-valid-inference" aria-label="Always Valid Inference">Always Valid Inference</a></li>
                <li>
                    <a href="#simulations" aria-label="Simulations">Simulations</a><ul>
                        
                <li>
                    <a href="#expan-flaw" aria-label="Expan Flaw">Expan Flaw</a></li>
                <li>
                    <a href="#monte-carlo" aria-label="Monte Carlo">Monte Carlo</a><ul>
                        
                <li>
                    <a href="#continuous-variable" aria-label="Continuous Variable">Continuous Variable</a><ul>
                        
                <li>
                    <a href="#false-positives" aria-label="False Positives">False Positives</a></li>
                <li>
                    <a href="#true-positives" aria-label="True Positives">True Positives</a></li></ul>
                </li>
                <li>
                    <a href="#conversion-rate" aria-label="Conversion Rate">Conversion Rate</a><ul>
                        
                <li>
                    <a href="#false-positives-1" aria-label="False Positives">False Positives</a></li>
                <li>
                    <a href="#true-positives-1" aria-label="True Positives">True Positives</a></li></ul>
                </li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#conclusion" aria-label="Conclusion">Conclusion</a></li>
                <li>
                    <a href="#references" aria-label="References">References</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><!-- comment it out
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>
-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>
<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>
<h1 id="intro">Intro<a hidden class="anchor" aria-hidden="true" href="#intro">#</a></h1>
<p>Sequential testing designs have gained significant popularity in AB testing due to their ability to potentially reduce the required sample size and experiment duration while maintaining statistical correctness. This approach allows for interim analyses of data as it accumulates, offering the possibility to stop the experiment early if a clear winner emerges, or if it becomes evident that the treatment effect is insufficient to justify continuing (stop for futility)</p>
<p>In this article, we shift our focus away from the theoretical intricacies of the problem and instead delve into a comprehensive exploration of available sequential testing solutions. We will discuss their implementations, compare their performance, and highlight their strengths and weaknesses. By examining these practical aspects, we aim to equip practitioners with the knowledge to make informed decisions when incorporating sequential testing into their AB testing workflows.</p>
<h1 id="approach">Approach<a hidden class="anchor" aria-hidden="true" href="#approach">#</a></h1>
<p>Among the variety of sequential testing designs, there are basically two broad families of algorithms: Group Sequential Testing (GST) and Always Valid Inference (AVI). These methods represent distinct philosophies in their handling of interim analyses and experiment stopping criteria..</p>
<ul>
<li>
<p>GST works with predefined interim analysis points and utilizes predetermined stopping boundaries to decide whether to stop the experiment at each stage.</p>
</li>
<li>
<p>AVI allows continuous monitoring and providing valid confident intervals at any point, making it adaptable for uncertain experiment duration or analysis frequencies.</p>
</li>
</ul>
<p>This article primarily focuses on these two techniques, providing an overview of their methodologies and practical implications.</p>
<h1 id="group-sequential-testing">Group Sequential Testing<a hidden class="anchor" aria-hidden="true" href="#group-sequential-testing">#</a></h1>
<p>For group sequential testing there is a handy <a href="https://github.com/cran/ldbounds/blob/master/R/ldBounds.R">package in R</a> and I will show below how to use it, although for those, who prefers Python due to any reason, whether it is the absence of an interpreter, infrastructure limitations or just personal preferences, there is no direct and popular alternative package, so I had to write it on my own and now ready to share with you after careful testing and benchmarking.</p>
<h2 id="gst-in-r">GST in R<a hidden class="anchor" aria-hidden="true" href="#gst-in-r">#</a></h2>
<p>If you&rsquo;re ready to use R library there are two options: use R runtime directly or through <code>rpy2</code> Python package.
Both options are available for example within Google Colab environment.</p>
<p>Here is an instance of <code>rpy2</code> package inference within Colab Notebook, when you run R code from the Python interpreter using an extension.</p>
<h3 id="ipython-notebook">iPython Notebook<a hidden class="anchor" aria-hidden="true" href="#ipython-notebook">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">%</span>load_ext rpy2<span style="color:#f92672">.</span>ipython
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">%%</span>R
</span></span><span style="display:flex;"><span>R<span style="color:#f92672">.</span>version<span style="color:#f92672">.</span>string
</span></span><span style="display:flex;"><span>install<span style="color:#f92672">.</span>packages(<span style="color:#e6db74">&#34;ldbounds&#34;</span>)
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">%%</span>R
</span></span><span style="display:flex;"><span>library(ldbounds)
</span></span><span style="display:flex;"><span>ldBounds(t<span style="color:#f92672">=</span>seq(<span style="color:#ae81ff">1</span><span style="color:#f92672">/</span><span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span><span style="color:#f92672">/</span><span style="color:#ae81ff">4</span>), iuse<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>, phi<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>, alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.05</span>, sides<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)<span style="color:#960050;background-color:#1e0010">$</span>upper<span style="color:#f92672">.</span>bounds
</span></span></code></pre></div><h3 id="python-file">Python File<a hidden class="anchor" aria-hidden="true" href="#python-file">#</a></h3>
<p>The code above may be rewritten into a simple <code>.py</code> file as follows, you are to use created <code>stats</code> package as a plain Python package thereafter.</p>
<blockquote>
<p><strong>‚ö†Ô∏è Caution</strong></p>
<p>It will not work in Google Colab for instance, as it requires R installed in addition to Python.</p>
</blockquote>
<details>
<summary>Code</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> rpy2.robjects.packages <span style="color:#66d9ef">as</span> rpackages
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> rpy2.robjects.vectors <span style="color:#f92672">import</span> StrVector
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>utils <span style="color:#f92672">=</span> rpackages<span style="color:#f92672">.</span>importr(<span style="color:#e6db74">&#39;utils&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># select a mirror for R packages</span>
</span></span><span style="display:flex;"><span>utils<span style="color:#f92672">.</span>chooseCRANmirror(ind<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># R package names</span>
</span></span><span style="display:flex;"><span>packnames <span style="color:#f92672">=</span> (<span style="color:#e6db74">&#39;ldbounds&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Selectively install what needs to be install.</span>
</span></span><span style="display:flex;"><span>names_to_install <span style="color:#f92672">=</span> [
</span></span><span style="display:flex;"><span>    package <span style="color:#66d9ef">for</span> package <span style="color:#f92672">in</span> packnames <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> rpackages<span style="color:#f92672">.</span>isinstalled(package)
</span></span><span style="display:flex;"><span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> len(names_to_install) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>    utils<span style="color:#f92672">.</span>install_packages(StrVector(names_to_install))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>stats <span style="color:#f92672">=</span> rpackages<span style="color:#f92672">.</span>importr(<span style="color:#e6db74">&#39;ldbounds&#39;</span>)
</span></span></code></pre></div></details>
<p>If R is not your cup of tea, or simply there is no option to run it within the scope of the production infrastructure, what is the most common limitation by the way, now begins exactly what you need.</p>
<h2 id="gst-in-python">GST in Python<a hidden class="anchor" aria-hidden="true" href="#gst-in-python">#</a></h2>
<p>There is quite popular incorrect implementation powered by Zalando <a href="https://github.com/zalando/expan/blob/master/expan/core/early_stopping.py"><code>expan</code></a></p>
<p>It works without probability integration and mistakenly leverage alpha spending function as a critical value at each step, it&rsquo;s common misunderstanding about alpha-spending function approach, there are number of implementations that do it the exact same wrong way, and even world&rsquo;s leading publication for data science, according to their own definition, makes the same mistakes, for instance: <a href="https://towardsdatascience.com/understanding-group-sequential-testing-befb35cec07a">Understanding of Group Sequential Testing published in Towards Data Science</a></p>
<p>As it will shown below that approach is statistically incorrect and so it&rsquo;s highly recommended to avoid it.</p>
<p>Instead I propose you to apply the new library <a href="https://github.com/NPodlozhniy/seqabpy"><code>seqabpy</code></a> that is powerful and accurate and what is more important implemented according to the original papers <a href="https://eclass.uoa.gr/modules/document/file.php/MATH301/PracticalSession3/LanDeMets.pdf">Interim analysis:
The alpha spending function approach by K. K. Gordon Lan and David L. DeMets (1983)</a> and further related publications, you may find them all mentioned in Reference lines of the methods&rsquo; docstrings, let&rsquo;s take a look at the functionality</p>
<details>
<summary>Code</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> numpy <span style="color:#66d9ef">as</span> np
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> pandas <span style="color:#66d9ef">as</span> pd
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> scipy.stats <span style="color:#f92672">import</span> norm
</span></span></code></pre></div></details>
<p><code>seabpy</code> provides Group Sequential Testing in a separate module - <code>gatsby</code> which name is an anagram of <strong>G</strong>roup <strong>S</strong>equential <strong>AB T</strong>esting in <strong>PY</strong>thon and below it&rsquo;s shown why <code>gatsby</code> is often referred as ¬´The Great Gatsby¬ª</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e">#!pip install seqabpy</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> seqabpy <span style="color:#f92672">import</span> gatsby
</span></span></code></pre></div><h3 id="lan-demets">Lan-DeMets<a hidden class="anchor" aria-hidden="true" href="#lan-demets">#</a></h3>
<p><code>calculate_sequential_bounds</code> function implements rigorous approach to calculate confidence bounds in one-sided GST.
In addition to upper bounds, if <code>beta</code> is provided it calculates lower bounds to unlock the option of stopping the test for futility, maintaining provided Type II error rate. The algorithm is taken from the article <a href="https://www.tandfonline.com/doi/abs/10.1080/03610929808832161">Group sequential designs using both type I and type II error probability spending functions by Chang MN, Hwang I, Shih WJ. (1998)</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>gatsby<span style="color:#f92672">.</span>calculate_sequential_bounds(np<span style="color:#f92672">.</span>linspace(<span style="color:#ae81ff">1</span><span style="color:#f92672">/</span><span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">10</span>), alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.05</span>, beta<span style="color:#f92672">=</span><span style="color:#ae81ff">0.2</span>)
</span></span></code></pre></div><pre><code>Sequential bounds algorithm to stop for futility converged to 0.00064 tolerance in 8 iterations using O'Brien-Fleming spending function.

(array([-3.02102866, -1.41478896, -0.59632535, -0.05664366,  0.35069266,
         0.68203514,  0.96419224,  1.21185008,  1.43395402,  1.79496377]),
 array([6.08789285, 4.22919942, 3.39632756, 2.90614903, 2.57897214,
        2.34174062, 2.15981329, 2.0146325 , 1.89528829, 1.79496377]))
</code></pre>
<p><code>ldBounds</code> function returns the exact same numbers as R package and tailored to have similar interface, in both input and output.</p>
<p>As a subtle benefit it supports more spending functions, take a look at the docstring to know more details.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>gatsby<span style="color:#f92672">.</span>ldBounds(t<span style="color:#f92672">=</span>np<span style="color:#f92672">.</span>linspace(<span style="color:#ae81ff">1</span><span style="color:#f92672">/</span><span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">4</span>), iuse<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>, phi<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)
</span></span></code></pre></div><pre><code>{'time.points': array([0.25, 0.5 , 0.75, 1.  ]),
 'alpha.spending': array([0.0125, 0.0125, 0.0125, 0.0125]),
 'overall.alpha': 0.05,
 'upper.bounds': array([2.24140273, 2.1251188 , 2.01870509, 1.92553052]),
 'nominal.alpha': array([0.0125    , 0.01678835, 0.02175894, 0.02708151])}
</code></pre>
<p>In case of calculation of upper bounds only the algorithm is faster, given that these boundaries shall be defined and fixed offline prior to the experiment start, it&rsquo;s totally sensible performance, when in addition lower aka futility bounds are computed it takes more time</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">%%</span>time
</span></span><span style="display:flex;"><span>gatsby<span style="color:#f92672">.</span>ldBounds(t<span style="color:#f92672">=</span>np<span style="color:#f92672">.</span>linspace(<span style="color:#ae81ff">1</span><span style="color:#f92672">/</span><span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">10</span>), alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.1</span>)
</span></span></code></pre></div><pre><code>CPU times: total: 7.73 s
Wall time: 7.75 s

{'time.points': array([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1. ]),
 'alpha.spending': array([1.97703624e-07, 2.34868089e-04, 2.43757240e-03, 6.62960181e-03,
        1.07070137e-02, 1.37029812e-02, 1.55891351e-02, 1.66134835e-02,
        1.70337597e-02, 1.70513868e-02]),
 'overall.alpha': 0.10000000000000009,
 'upper.bounds': array([5.07115563, 3.4973068 , 2.79510152, 2.38848818, 2.11870064,
        1.92350461, 1.77394818, 1.65463799, 1.55659472, 1.47418673]),
 'nominal.alpha': array([1.97703624e-07, 2.34990500e-04, 2.59417098e-03, 8.45892623e-03,
        1.70578873e-02, 2.72083541e-02, 3.80358613e-02, 4.89989759e-02,
        5.97833696e-02, 7.02156613e-02])}
</code></pre>
<p>An example of less popular Haybittle-Peto spending function usage</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>gatsby<span style="color:#f92672">.</span>ldBounds(t<span style="color:#f92672">=</span>np<span style="color:#f92672">.</span>linspace(<span style="color:#ae81ff">1</span><span style="color:#f92672">/</span><span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">4</span>), iuse<span style="color:#f92672">=</span><span style="color:#ae81ff">5</span>)
</span></span></code></pre></div><pre><code>{'time.points': array([0.25, 0.5 , 0.75, 1.  ]),
 'alpha.spending': array([0.0013499, 0.       , 0.       , 0.0486501]),
 'overall.alpha': 0.05,
 'upper.bounds': array([3.        , 3.        , 3.        , 1.63391418]),
 'nominal.alpha': array([0.0013499 , 0.0013499 , 0.0013499 , 0.05113844])}
</code></pre>
<h3 id="gst">GST<a hidden class="anchor" aria-hidden="true" href="#gst">#</a></h3>
<p><code>GST</code> is the general function that accounts for various deviations in the experiment design, in other words if the peeking strategy is different the method adjusts the bounds to guarantee the valid statistical approach whenever it&rsquo;s possible.</p>
<p>In particular it&rsquo;s perfect to handle a few changed peeking points when the total number of peeking remains the same, and it works in a best possible way with under- and oversampling, in the latter case the procedure is not fully correct though as we will see in the simulations part.</p>
<p>The idea of implementation is taken from <a href="https://link.springer.com/book/10.1007/978-3-319-32562-0">Group Sequential and Confirmatory Adaptive Designs in Clinical Trials by G. Wassmer and W. Brannath (2016)</a></p>
<p>Here are a few examples, that shows how different peeking strategy affects the bounds:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>gatsby<span style="color:#f92672">.</span>ldBounds(t<span style="color:#f92672">=</span>np<span style="color:#f92672">.</span>array([<span style="color:#ae81ff">0.3</span>, <span style="color:#ae81ff">0.6</span>, <span style="color:#ae81ff">1.0</span>]), alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.025</span>)
</span></span></code></pre></div><pre><code>{'time.points': array([0.3, 0.6, 1. ]),
 'alpha.spending': array([4.27257874e-05, 3.76533752e-03, 2.11919367e-02]),
 'overall.alpha': 0.02499999999999991,
 'upper.bounds': array([3.92857254, 2.669972  , 1.98103004]),
 'nominal.alpha': array([4.27257874e-05, 3.79287858e-03, 2.37939526e-02])}
</code></pre>
<ul>
<li>in case of under-sampling the last upper bound is lower what reflects that all the rest of alpha volume is spent at this point</li>
<li>in case of over-sampling the last upper bound is higher, what helps to control Type I error rate, after the expected sample size is reached</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>gatsby<span style="color:#f92672">.</span>GST(actual<span style="color:#f92672">=</span>np<span style="color:#f92672">.</span>array([<span style="color:#ae81ff">0.3</span>, <span style="color:#ae81ff">0.6</span>, <span style="color:#ae81ff">0.8</span>]), expected<span style="color:#f92672">=</span>np<span style="color:#f92672">.</span>array([<span style="color:#ae81ff">0.3</span>, <span style="color:#ae81ff">0.6</span>, <span style="color:#ae81ff">1</span>]), alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.025</span>)
</span></span></code></pre></div><pre><code>array([3.92857254, 2.669972  , 1.96890411])
</code></pre>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>gatsby<span style="color:#f92672">.</span>GST(actual<span style="color:#f92672">=</span>np<span style="color:#f92672">.</span>array([<span style="color:#ae81ff">0.3</span>, <span style="color:#ae81ff">0.6</span>, <span style="color:#ae81ff">1.2</span>]), expected<span style="color:#f92672">=</span>np<span style="color:#f92672">.</span>array([<span style="color:#ae81ff">0.3</span>, <span style="color:#ae81ff">0.6</span>, <span style="color:#ae81ff">1</span>]), alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.025</span>)
</span></span></code></pre></div><pre><code>array([3.92857254, 2.669972  , 1.98949242])
</code></pre>
<p>Under- and over- sampling may also happen in a more natural way, when a few peeking points are added or removed</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>gatsby<span style="color:#f92672">.</span>ldBounds(t<span style="color:#f92672">=</span>np<span style="color:#f92672">.</span>array([<span style="color:#ae81ff">0.3</span>, <span style="color:#ae81ff">0.6</span>, <span style="color:#ae81ff">0.8</span>, <span style="color:#ae81ff">1.0</span>]), alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.025</span>)
</span></span></code></pre></div><pre><code>{'time.points': array([0.3, 0.6, 0.8, 1. ]),
 'alpha.spending': array([4.27257874e-05, 3.76533752e-03, 8.40372704e-03, 1.27882097e-02]),
 'overall.alpha': 0.02499999999999991,
 'upper.bounds': array([3.92857254, 2.669972  , 2.28886308, 2.03074404]),
 'nominal.alpha': array([4.27257874e-05, 3.79287858e-03, 1.10436544e-02, 2.11404831e-02])}
</code></pre>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>gatsby<span style="color:#f92672">.</span>GST(actual<span style="color:#f92672">=</span>np<span style="color:#f92672">.</span>array([<span style="color:#ae81ff">0.3</span>, <span style="color:#ae81ff">0.6</span>, <span style="color:#ae81ff">0.8</span>]), expected<span style="color:#f92672">=</span>np<span style="color:#f92672">.</span>array([<span style="color:#ae81ff">0.3</span>, <span style="color:#ae81ff">0.6</span>, <span style="color:#ae81ff">0.8</span>, <span style="color:#ae81ff">1</span>]), alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.025</span>)
</span></span></code></pre></div><pre><code>array([3.92857254, 2.669972  , 2.15083427])
</code></pre>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>gatsby<span style="color:#f92672">.</span>GST(actual<span style="color:#f92672">=</span>np<span style="color:#f92672">.</span>array([<span style="color:#ae81ff">0.3</span>, <span style="color:#ae81ff">0.6</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1.2</span>]), expected<span style="color:#f92672">=</span>np<span style="color:#f92672">.</span>array([<span style="color:#ae81ff">0.3</span>, <span style="color:#ae81ff">0.6</span>, <span style="color:#ae81ff">1</span>]), alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.025</span>)
</span></span></code></pre></div><pre><code>array([3.92857254, 2.669972  , 1.98102292, 2.0375539 ])
</code></pre>
<p><code>GST</code> also supports <code>int</code> as an input, if peeking point are distributed uniformly it&rsquo;s what you should use in sake of convenience</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>gatsby<span style="color:#f92672">.</span>GST(<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">7</span>)
</span></span></code></pre></div><pre><code>array([5.05481268, 3.48557771, 2.78550934, 2.38021304, 2.1113425 ,
       1.9168349 , 1.76778516])
</code></pre>
<p>While the method comes handy in most of scenarios, it doesn&rsquo;t support all the possible deviations: the beginning of the expected and actual peeking strategies must be the same: so it&rsquo;s either over- or under- sampling or the change in peeking points when their number remains equal</p>
<p>Needless to say that the application of <code>GST</code> and other functions mentioned above apparently is not limited to one-sided hypotheses, in order to test two-sided alternative: just set $\alpha$ to half of the value, like <code>0.025</code> if you want to challenge two-sided hypothesis at <code>0.95</code> confidence level, and define lower bounds symmetrically about zero, so they would be the same in absolute values, but negative.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>gatsby<span style="color:#f92672">.</span>GST(actual<span style="color:#f92672">=</span>np<span style="color:#f92672">.</span>array([<span style="color:#ae81ff">0.3</span>, <span style="color:#ae81ff">0.6</span>, <span style="color:#ae81ff">0.9</span>, <span style="color:#ae81ff">1.2</span>]), expected<span style="color:#f92672">=</span>np<span style="color:#f92672">.</span>array([<span style="color:#ae81ff">0.3</span>, <span style="color:#ae81ff">0.6</span>, <span style="color:#ae81ff">0.8</span>, <span style="color:#ae81ff">1</span>]), alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.025</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># the following will not work</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># gatsby.GST(actual=np.array([0.3, 0.6]), expected=np.array([0.8, 1]))</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># gatsby.GST(</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#     actual=np.array([0.3, 0.5, 0.6, 0.7, 0.8, 0.9, 1]),</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#     expected=np.array([0.3, 0.6, 0.8, 1])</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># )</span>
</span></span></code></pre></div><pre><code>array([3.92857254, 2.669972  , 2.30467653, 2.05129976])
</code></pre>
<h1 id="always-valid-inference">Always Valid Inference<a hidden class="anchor" aria-hidden="true" href="#always-valid-inference">#</a></h1>
<p>While AVI is becoming increasingly popular in the field, bypassing GST, it&rsquo;s worth noting that there are currently no widely adopted, comprehensive Python or R packages that focus solely on this approach.</p>
<p>There is one recent package <code>savvi</code> appeared this year, but it&rsquo;s still in <code>v0..</code> version and have not been yet fully acknowledged by the community. What is more it focuses only on the publications of Lindon et al.¬†from <a href="https://openreview.net/pdf?id=a4zg0jiuVi">2022</a> and <a href="https://arxiv.org/pdf/2210.08589">2024</a>, while there are other notable authors like <a href="https://arxiv.org/pdf/1905.10493">Zhao et al.</a> and <a href="https://arxiv.org/abs/1810.08240">Howard et al.</a> whose approach will be challenged in addition to Lindon&rsquo;s work</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> seqabpy <span style="color:#f92672">import</span> gavi
</span></span></code></pre></div><p><code>seqabpy</code> provides Always Valid Inference functionality in <code>gavi</code> module where as of now, <code>AlwaysValidInference</code> is a main class that implements confidence intervals valid at any point.
While intervals and namely their continuous comparison to the current z-score provides the apparatus that is just enough for practical decisions, <code>p-values</code> are to be released later as well, to complete experiment analysis picture.</p>
<p><code>AlwaysValidInference</code> an array of sample sizes when the peeking happens along with the metric variance and the result point difference.
Multiple supported properties comprise different algorithms (the detailed description may be found in each docsrting) that return a boolean array indicating whether the null hypothesis is rejected in favour of one- or two- sided alternative for each size.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>avi <span style="color:#f92672">=</span> gavi<span style="color:#f92672">.</span>AlwaysValidInference(size<span style="color:#f92672">=</span>np<span style="color:#f92672">.</span>arange(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">10</span>), sigma2<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>, estimate<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)
</span></span></code></pre></div><p><code>GAVI</code> is the method proposed by Howard et al.¬†and widely adopted in tech by Eppo</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>avi<span style="color:#f92672">.</span>GAVI(<span style="color:#ae81ff">50</span>)
</span></span></code></pre></div><pre><code>array([False,  True,  True,  True,  True,  True,  True,  True,  True])
</code></pre>
<p><code>mSPRT</code> is the approach proposed by M. Lindon in his article and is leveraged by Netflix</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>avi<span style="color:#f92672">.</span>mSPRT(<span style="color:#ae81ff">0.08</span>)
</span></span></code></pre></div><pre><code>array([False, False,  True,  True,  True,  True,  True,  True,  True])
</code></pre>
<p><code>StatSig_SPRT</code> is the variation proposed by Zhao et al.¬†and as it comes from the name used currently by StatSig</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>avi<span style="color:#f92672">.</span>StatSig_SPRT()
</span></span></code></pre></div><pre><code>array([False,  True,  True,  True,  True,  True,  True,  True,  True])
</code></pre>
<p>The last and, this time, indeed least heavily criticized <code>statsig_alpha_corrected_v1</code> approach, which was their first attempt to furnish their platform with a sequential testing framework. It&rsquo;s mainly added for the reference to show how sequential testing must not work like</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>avi<span style="color:#f92672">.</span>statsig_alpha_corrected_v1(<span style="color:#ae81ff">100</span>)
</span></span></code></pre></div><pre><code>array([False, False, False,  True,  True,  True,  True,  True,  True])
</code></pre>
<h1 id="simulations">Simulations<a hidden class="anchor" aria-hidden="true" href="#simulations">#</a></h1>
<p>For those who have visited my blog before, there is nothing new in how we will conduct testing, it is good old Monte Carlo. For more details checkout my previous posts like <a href="https://npodlozhniy.github.io/posts/dunnett-correction/#canonical-ab-test">Dunnett&rsquo;s Correction for ABC testing</a></p>
<p>We will measure False and True positive rates for two kinds of the target metric: a continuous variable and a conversion. Furthermore we will learn how tolerant are different methods to under- and over- sampling.</p>
<details>
<summary>Code</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Global simulation settings</span>
</span></span><span style="display:flex;"><span>N <span style="color:#f92672">=</span> <span style="color:#ae81ff">500</span>
</span></span><span style="display:flex;"><span>alpha <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.05</span>
</span></span><span style="display:flex;"><span>n_iterations <span style="color:#f92672">=</span> <span style="color:#ae81ff">100_000</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">stops_at</span>(is_significant: np<span style="color:#f92672">.</span>ndarray, sample_size: np<span style="color:#f92672">.</span>ndarray) <span style="color:#f92672">-&gt;</span> int:
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    Determines the stopping sample size.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    This function identifies the first instance where the input
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    condition is True and returns the corresponding sample size.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    Args:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        is_significant: A boolean array of the stop condition for each size
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        sample_size: An array of sample sizes.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    Returns:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        The stopping sample size.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    Example:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        &gt;&gt;&gt; detN([False, False, True, True], [50, 100, 150, 200])
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        150
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(is_significant) <span style="color:#f92672">!=</span> len(sample_size):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">ValueError</span>(<span style="color:#e6db74">&#34;Input arrays must have the same length.&#34;</span>)
</span></span><span style="display:flex;"><span>    w <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>where(is_significant)[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">None</span> <span style="color:#66d9ef">if</span> len(w) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">else</span> sample_size[w[<span style="color:#ae81ff">0</span>]]
</span></span></code></pre></div></details>
<p>One thing about GST is that incredible freedom in spending function choice what makes it possible to experiment and find the best fit for your data.
For demonstration purposes I suggest using Kim-DeMets spending function with different values of the power $\phi$: the higher $\phi$ the more strict the function is at the beginning of the experiment.</p>
<details>
<summary>Code</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>gst_linear <span style="color:#f92672">=</span> gatsby<span style="color:#f92672">.</span>GST(actual<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>, expected<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>, iuse<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>, phi<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>, alpha<span style="color:#f92672">=</span>alpha)
</span></span><span style="display:flex;"><span>gst_quadratic <span style="color:#f92672">=</span> gatsby<span style="color:#f92672">.</span>GST(actual<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>, expected<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>, iuse<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>, phi<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>, alpha<span style="color:#f92672">=</span>alpha)
</span></span><span style="display:flex;"><span>gst_cubic <span style="color:#f92672">=</span> gatsby<span style="color:#f92672">.</span>GST(actual<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>, expected<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>, iuse<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>, phi<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>, alpha<span style="color:#f92672">=</span>alpha)
</span></span></code></pre></div></details>
<p>You can play around the trade-off: would you like to spend more $\alpha$ at the start, detecting faster if there are greater uplifts in you experiment group or to preserve the major part of alpha until the end keeping maximum power to reject the hypothesis when the expected sample size is reached.</p>
<blockquote>
<p><strong>üí° Tip</strong></p>
<p>If the title or the legend items are not visible to you - double click to one of legend items and it will make the chart rendered properly. It may happen due to LaTeX usage.</p>
</blockquote>
<details>
<summary>Code</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> plotly.express <span style="color:#66d9ef">as</span> px
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> plotly.graph_objs <span style="color:#66d9ef">as</span> go
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">hex2rgba</span>(hex, alpha):
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    Convert plotly hex colors to rgb and enables transparency adjustment
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    col_hex <span style="color:#f92672">=</span> hex<span style="color:#f92672">.</span>lstrip(<span style="color:#e6db74">&#39;#&#39;</span>)
</span></span><span style="display:flex;"><span>    col_rgb <span style="color:#f92672">=</span> tuple(int(col_hex[i : i <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>], <span style="color:#ae81ff">16</span>) <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> (<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span>))
</span></span><span style="display:flex;"><span>    col_rgb <span style="color:#f92672">+=</span> (alpha,)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#39;rgba&#39;</span> <span style="color:#f92672">+</span> str(col_rgb)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_new_color</span>(colors):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> <span style="color:#66d9ef">True</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> color <span style="color:#f92672">in</span> colors:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">yield</span> color
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>colors_list <span style="color:#f92672">=</span> px<span style="color:#f92672">.</span>colors<span style="color:#f92672">.</span>qualitative<span style="color:#f92672">.</span>Plotly
</span></span><span style="display:flex;"><span>rgba_colors <span style="color:#f92672">=</span> [hex2rgba(color, alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.5</span>) <span style="color:#66d9ef">for</span> color <span style="color:#f92672">in</span> colors_list]
</span></span><span style="display:flex;"><span>palette <span style="color:#f92672">=</span> get_new_color(rgba_colors)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">add_chart</span>(figure, data, title<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    x <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>arange(<span style="color:#ae81ff">1</span>, len(data) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">/</span> len(data)
</span></span><span style="display:flex;"><span>    color <span style="color:#f92672">=</span> next(palette)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    figure<span style="color:#f92672">.</span>add_trace(
</span></span><span style="display:flex;"><span>        go<span style="color:#f92672">.</span>Scatter(
</span></span><span style="display:flex;"><span>            name<span style="color:#f92672">=</span>title,
</span></span><span style="display:flex;"><span>            x<span style="color:#f92672">=</span>x,
</span></span><span style="display:flex;"><span>            y<span style="color:#f92672">=</span>data,
</span></span><span style="display:flex;"><span>            mode<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;lines&#39;</span>,
</span></span><span style="display:flex;"><span>            line<span style="color:#f92672">=</span>dict(color<span style="color:#f92672">=</span>color, width<span style="color:#f92672">=</span><span style="color:#ae81ff">4</span>, dash<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;solid&#39;</span>),
</span></span><span style="display:flex;"><span>            hovertemplate<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;%</span><span style="color:#e6db74">{y:.3f}</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>        ),
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>figure <span style="color:#f92672">=</span> go<span style="color:#f92672">.</span>Figure()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>add_chart(figure, gst_linear, <span style="color:#e6db74">r</span><span style="color:#e6db74">&#34;$\text</span><span style="color:#e6db74">{Linear: }</span><span style="color:#e6db74"> \phi = 1$&#34;</span>)
</span></span><span style="display:flex;"><span>add_chart(figure, gst_quadratic, <span style="color:#e6db74">r</span><span style="color:#e6db74">&#34;$\text</span><span style="color:#e6db74">{Quadratic: }</span><span style="color:#e6db74"> \phi = 2$&#34;</span>)
</span></span><span style="display:flex;"><span>add_chart(figure, gst_cubic, <span style="color:#e6db74">r</span><span style="color:#e6db74">&#34;$\text</span><span style="color:#e6db74">{Cubic: }</span><span style="color:#e6db74"> \phi = 3$&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>figure<span style="color:#f92672">.</span>update_xaxes(
</span></span><span style="display:flex;"><span>    title_text<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Peeking moments&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>figure<span style="color:#f92672">.</span>update_layout(
</span></span><span style="display:flex;"><span>    yaxis_title<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Critical value for z-score&#34;</span>,
</span></span><span style="display:flex;"><span>    title<span style="color:#f92672">=</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;x&#34;</span>: <span style="color:#ae81ff">0.5</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;text&#34;</span>: <span style="color:#e6db74">r</span><span style="color:#e6db74">&#34;$\text{Kim-DeMets spending function: } \alpha \cdot t^{\phi} \text{ differences}$&#34;</span>,
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>    hovermode<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;x&#34;</span>,
</span></span><span style="display:flex;"><span>    template<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;plotly_dark&#34;</span>,
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>figure<span style="color:#f92672">.</span>write_json(<span style="color:#e6db74">&#34;alpha-spending-functions-comparison.json&#34;</span>)
</span></span><span style="display:flex;"><span>figure<span style="color:#f92672">.</span>show()
</span></span></code></pre></div></details>


<div id="plotly-001"></div>

<script>
  Plotly.newPlot(document.getElementById("plotly-001"), {"data":[{"hovertemplate":"%{y:.3f}","line":{"color":"rgba(99, 110, 250, 0.5)","dash":"solid","width":4},"mode":"lines","name":"$\\text{Linear: } \\phi = 1$","type":"scatter","x":[0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1],"y":[2.5758293035489004,2.491969213676734,2.4108136446184645,2.3391395213026143,2.275522865975437,2.2182981940241957,2.1661802332245723,2.1182008385119016,2.0736542918950174,2.031959642568662]},{"hovertemplate":"%{y:.3f}","line":{"color":"rgba(239, 85, 59, 0.5)","dash":"solid","width":4},"mode":"lines","name":"$\\text{Quadratic: } \\phi = 2$","type":"scatter","x":[0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1],"y":[3.2905267314919255,2.9404087319874503,2.7211012643626593,2.5480990360307336,2.401157438066114,2.271280933056511,2.153589945847508,2.0450289905949433,1.9435294445184343,1.8476620257972045]},{"hovertemplate":"%{y:.3f}","line":{"color":"rgba(0, 204, 150, 0.5)","dash":"solid","width":4},"mode":"lines","name":"$\\text{Cubic: } \\phi = 3$","type":"scatter","x":[0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1],"y":[3.8905918864131204,3.379585959430083,3.0583406669780993,2.8070680020476098,2.593431791637877,2.403577570997695,2.2299478498313703,2.067901543147874,1.9143146861520617,1.7668907704610233]}],"layout":{"hovermode":"x","template":{"data":{"bar":[{"error_x":{"color":"#f2f5fa"},"error_y":{"color":"#f2f5fa"},"marker":{"line":{"color":"rgb(17,17,17)","width":0.5},"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"bar"}],"barpolar":[{"marker":{"line":{"color":"rgb(17,17,17)","width":0.5},"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"barpolar"}],"carpet":[{"aaxis":{"endlinecolor":"#A2B1C6","gridcolor":"#506784","linecolor":"#506784","minorgridcolor":"#506784","startlinecolor":"#A2B1C6"},"baxis":{"endlinecolor":"#A2B1C6","gridcolor":"#506784","linecolor":"#506784","minorgridcolor":"#506784","startlinecolor":"#A2B1C6"},"type":"carpet"}],"choropleth":[{"colorbar":{"outlinewidth":0,"ticks":""},"type":"choropleth"}],"contour":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"contour"}],"contourcarpet":[{"colorbar":{"outlinewidth":0,"ticks":""},"type":"contourcarpet"}],"heatmap":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"heatmap"}],"heatmapgl":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"heatmapgl"}],"histogram":[{"marker":{"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"histogram"}],"histogram2d":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"histogram2d"}],"histogram2dcontour":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"histogram2dcontour"}],"mesh3d":[{"colorbar":{"outlinewidth":0,"ticks":""},"type":"mesh3d"}],"parcoords":[{"line":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"parcoords"}],"pie":[{"automargin":true,"type":"pie"}],"scatter":[{"marker":{"line":{"color":"#283442"}},"type":"scatter"}],"scatter3d":[{"line":{"colorbar":{"outlinewidth":0,"ticks":""}},"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scatter3d"}],"scattercarpet":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scattercarpet"}],"scattergeo":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scattergeo"}],"scattergl":[{"marker":{"line":{"color":"#283442"}},"type":"scattergl"}],"scattermapbox":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scattermapbox"}],"scatterpolar":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scatterpolar"}],"scatterpolargl":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scatterpolargl"}],"scatterternary":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scatterternary"}],"surface":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"surface"}],"table":[{"cells":{"fill":{"color":"#506784"},"line":{"color":"rgb(17,17,17)"}},"header":{"fill":{"color":"#2a3f5f"},"line":{"color":"rgb(17,17,17)"}},"type":"table"}]},"layout":{"annotationdefaults":{"arrowcolor":"#f2f5fa","arrowhead":0,"arrowwidth":1},"autotypenumbers":"strict","coloraxis":{"colorbar":{"outlinewidth":0,"ticks":""}},"colorscale":{"diverging":[[0,"#8e0152"],[0.1,"#c51b7d"],[0.2,"#de77ae"],[0.3,"#f1b6da"],[0.4,"#fde0ef"],[0.5,"#f7f7f7"],[0.6,"#e6f5d0"],[0.7,"#b8e186"],[0.8,"#7fbc41"],[0.9,"#4d9221"],[1,"#276419"]],"sequential":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"sequentialminus":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]]},"colorway":["#636efa","#EF553B","#00cc96","#ab63fa","#FFA15A","#19d3f3","#FF6692","#B6E880","#FF97FF","#FECB52"],"font":{"color":"#f2f5fa"},"geo":{"bgcolor":"rgb(17,17,17)","lakecolor":"rgb(17,17,17)","landcolor":"rgb(17,17,17)","showlakes":true,"showland":true,"subunitcolor":"#506784"},"hoverlabel":{"align":"left"},"hovermode":"closest","mapbox":{"style":"dark"},"paper_bgcolor":"rgb(17,17,17)","plot_bgcolor":"rgb(17,17,17)","polar":{"angularaxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""},"bgcolor":"rgb(17,17,17)","radialaxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""}},"scene":{"xaxis":{"backgroundcolor":"rgb(17,17,17)","gridcolor":"#506784","gridwidth":2,"linecolor":"#506784","showbackground":true,"ticks":"","zerolinecolor":"#C8D4E3"},"yaxis":{"backgroundcolor":"rgb(17,17,17)","gridcolor":"#506784","gridwidth":2,"linecolor":"#506784","showbackground":true,"ticks":"","zerolinecolor":"#C8D4E3"},"zaxis":{"backgroundcolor":"rgb(17,17,17)","gridcolor":"#506784","gridwidth":2,"linecolor":"#506784","showbackground":true,"ticks":"","zerolinecolor":"#C8D4E3"}},"shapedefaults":{"line":{"color":"#f2f5fa"}},"sliderdefaults":{"bgcolor":"#C8D4E3","bordercolor":"rgb(17,17,17)","borderwidth":1,"tickwidth":0},"ternary":{"aaxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""},"baxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""},"bgcolor":"rgb(17,17,17)","caxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""}},"title":{"x":0.05},"updatemenudefaults":{"bgcolor":"#506784","borderwidth":0},"xaxis":{"automargin":true,"gridcolor":"#283442","linecolor":"#506784","ticks":"","title":{"standoff":15},"zerolinecolor":"#283442","zerolinewidth":2},"yaxis":{"automargin":true,"gridcolor":"#283442","linecolor":"#506784","ticks":"","title":{"standoff":15},"zerolinecolor":"#283442","zerolinewidth":2}}},"title":{"text":"$\\text{Kim-DeMets spending function: } \\alpha \\cdot t^{\\phi} \\text{ differences}$","x":0.5},"xaxis":{"title":{"text":"Peeking moments"}},"yaxis":{"title":{"text":"Critical value for z-score"}}}});
</script>
<h2 id="expan-flaw">Expan Flaw<a hidden class="anchor" aria-hidden="true" href="#expan-flaw">#</a></h2>
<p>Remember I promised to show, that <code>expan</code> way to determine boundaries is wrong, so here is a quick proof: the code is taken without changes from their GitHub: <a href="https://github.com/zalando/expan/blob/master/expan/core/early_stopping.py">zalando/expan/early_stopping</a></p>
<details>
<summary>Code</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> statsmodels.stats.proportion <span style="color:#f92672">import</span> proportion_confint
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sample_size</span>(x):
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34; Calculates valid sample size given the data.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    :param x: sample to calculate the sample size
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    :type  x: pd.Series or list (array-like)
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    :return: sample size of the sample excluding nans
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    :rtype: int
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># cast into a dummy numpy array to infer the dtype</span>
</span></span><span style="display:flex;"><span>    x_as_array <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array(x)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> np<span style="color:#f92672">.</span>issubdtype(x_as_array<span style="color:#f92672">.</span>dtype, np<span style="color:#f92672">.</span>number):
</span></span><span style="display:flex;"><span>        _x <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array(x, dtype<span style="color:#f92672">=</span>float)
</span></span><span style="display:flex;"><span>        x_nan <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>isnan(_x)<span style="color:#f92672">.</span>sum()
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># assuming categorical sample</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">elif</span> isinstance(x, pd<span style="color:#f92672">.</span>core<span style="color:#f92672">.</span>series<span style="color:#f92672">.</span>Series):
</span></span><span style="display:flex;"><span>        x_nan <span style="color:#f92672">=</span> x<span style="color:#f92672">.</span>str<span style="color:#f92672">.</span>contains(<span style="color:#e6db74">&#39;NA&#39;</span>)<span style="color:#f92672">.</span>sum()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        x_nan <span style="color:#f92672">=</span> list(x)<span style="color:#f92672">.</span>count(<span style="color:#e6db74">&#39;NA&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> int(len(x) <span style="color:#f92672">-</span> x_nan)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">obrien_fleming</span>(information_fraction, alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.05</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34; Calculate an approximation of the O&#39;Brien-Fleming alpha spending function.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    :param information_fraction: share of the information  amount at the point of evaluation,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                                 e.g. the share of the maximum sample size
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    :type  information_fraction: float
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    :param alpha: type-I error rate
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    :type  alpha: float
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    :return: redistributed alpha value at the time point with the given information fraction
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    :rtype:  float
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> norm<span style="color:#f92672">.</span>cdf(norm<span style="color:#f92672">.</span>ppf(<span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> alpha <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>) <span style="color:#f92672">/</span> np<span style="color:#f92672">.</span>sqrt(information_fraction))) <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">group_sequential</span>(x, y, spending_function<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;obrien_fleming&#39;</span>, estimated_sample_size<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>, alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.05</span>, cap<span style="color:#f92672">=</span><span style="color:#ae81ff">8</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34; Group sequential method to determine whether to stop early.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    :param x: sample of a treatment group
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    :type  x: pd.Series or array-like
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    :param y: sample of a control group
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    :type  y: pd.Series or array-like
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    :param spending_function: name of the alpha spending function, currently supports only &#39;obrien_fleming&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    :type  spending_function: str
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    :param estimated_sample_size: sample size to be achieved towards the end of experiment
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    :type  estimated_sample_size: int
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    :param alpha: type-I error rate
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    :type  alpha: float
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    :param cap: upper bound of the adapted z-score
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    :type  cap: int
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    :return: results of type EarlyStoppingTestStatistics
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    :rtype:  EarlyStoppingTestStatistics
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Coercing missing values to right format</span>
</span></span><span style="display:flex;"><span>    _x <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array(x, dtype<span style="color:#f92672">=</span>float)
</span></span><span style="display:flex;"><span>    _y <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array(y, dtype<span style="color:#f92672">=</span>float)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    n_x <span style="color:#f92672">=</span> sample_size(_x)
</span></span><span style="display:flex;"><span>    n_y <span style="color:#f92672">=</span> sample_size(_y)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> estimated_sample_size:
</span></span><span style="display:flex;"><span>        information_fraction <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        information_fraction <span style="color:#f92672">=</span> min(<span style="color:#ae81ff">1.0</span>, (n_x <span style="color:#f92672">+</span> n_y) <span style="color:#f92672">/</span> estimated_sample_size)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># alpha spending function</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> spending_function <span style="color:#f92672">in</span> (<span style="color:#e6db74">&#39;obrien_fleming&#39;</span>):
</span></span><span style="display:flex;"><span>        func <span style="color:#f92672">=</span> eval(spending_function)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">NotImplementedError</span>
</span></span><span style="display:flex;"><span>    alpha_new <span style="color:#f92672">=</span> func(information_fraction, alpha<span style="color:#f92672">=</span>alpha)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># calculate the z-score bound</span>
</span></span><span style="display:flex;"><span>    bound <span style="color:#f92672">=</span> norm<span style="color:#f92672">.</span>ppf(<span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> alpha_new <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># replace potential inf with an upper bound</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> bound <span style="color:#f92672">==</span> np<span style="color:#f92672">.</span>inf:
</span></span><span style="display:flex;"><span>        bound <span style="color:#f92672">=</span> cap
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    mu_x <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>nanmean(_x)
</span></span><span style="display:flex;"><span>    mu_y <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>nanmean(_y)
</span></span><span style="display:flex;"><span>    sigma_x <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>nanstd(_x)
</span></span><span style="display:flex;"><span>    sigma_y <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>nanstd(_y)
</span></span><span style="display:flex;"><span>    z <span style="color:#f92672">=</span> (mu_x <span style="color:#f92672">-</span> mu_y) <span style="color:#f92672">/</span> np<span style="color:#f92672">.</span>sqrt(sigma_x <span style="color:#f92672">**</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">/</span> n_x <span style="color:#f92672">+</span> sigma_y <span style="color:#f92672">**</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">/</span> n_y)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> z <span style="color:#f92672">&gt;</span> bound <span style="color:#f92672">or</span> z <span style="color:#f92672">&lt;</span> <span style="color:#f92672">-</span>bound:
</span></span><span style="display:flex;"><span>        stop <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        stop <span style="color:#f92672">=</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> stop
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>fpr <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> r <span style="color:#f92672">in</span> range(n_iterations):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    x <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>normal(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, N)
</span></span><span style="display:flex;"><span>    y <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>normal(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, N)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> current_size <span style="color:#f92672">in</span> np<span style="color:#f92672">.</span>linspace(N<span style="color:#f92672">/</span><span style="color:#ae81ff">10</span>, N, <span style="color:#ae81ff">10</span>)<span style="color:#f92672">.</span>astype(int):
</span></span><span style="display:flex;"><span>        stopping <span style="color:#f92672">=</span> group_sequential(x[:current_size], y[:current_size], estimated_sample_size<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>N, alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.05</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> stopping:
</span></span><span style="display:flex;"><span>            fpr <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>l, r <span style="color:#f92672">=</span> proportion_confint(count<span style="color:#f92672">=</span>fpr, nobs<span style="color:#f92672">=</span>n_iterations, alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.10</span>, method<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;wilson&#39;</span>)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;false positives: </span><span style="color:#e6db74">{</span>fpr<span style="color:#f92672">/</span>n_iterations<span style="color:#e6db74">:</span><span style="color:#e6db74">.3f</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> ¬± </span><span style="color:#e6db74">{</span>(r <span style="color:#f92672">-</span> l) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span><span style="color:#e6db74">:</span><span style="color:#e6db74">.3f</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> is significantly higher than </span><span style="color:#e6db74">{</span>alpha<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span></code></pre></div></details>
<p>So, as was said above, it doesn&rsquo;t control FPR as it should according to Group Sequential Testing problem design and hence this myth of the direct application of alpha spending function have to be dispelled: it doesn&rsquo;t work this way and further you will see that it&rsquo;s not much better than custom ad-hoc corrections.</p>
<blockquote>
<p><strong>‚ö†Ô∏è Warning</strong></p>
<p>Please, do not use <code>expan</code> for sequential testing as their implementation is wrong.</p>
</blockquote>
<h2 id="monte-carlo">Monte Carlo<a hidden class="anchor" aria-hidden="true" href="#monte-carlo">#</a></h2>
<details>
<summary>Code</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> collections <span style="color:#f92672">import</span> defaultdict
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">monte_carlo</span>(
</span></span><span style="display:flex;"><span>    metric: str<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;normal&#34;</span>,
</span></span><span style="display:flex;"><span>    sampling: str<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;accurate&#34;</span>,
</span></span><span style="display:flex;"><span>    effect_size: float<span style="color:#f92672">=</span><span style="color:#ae81ff">0.10</span>,
</span></span><span style="display:flex;"><span>    aa_test: bool<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>,
</span></span><span style="display:flex;"><span>    N: int <span style="color:#f92672">=</span> N,
</span></span><span style="display:flex;"><span>) <span style="color:#f92672">-&gt;</span> pd<span style="color:#f92672">.</span>DataFrame:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    result <span style="color:#f92672">=</span> defaultdict(list)
</span></span><span style="display:flex;"><span>    eff <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">if</span> aa_test <span style="color:#66d9ef">else</span> effect_size
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> metric <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;normal&#34;</span>:
</span></span><span style="display:flex;"><span>        mu, sigma <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        p <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.10</span>
</span></span><span style="display:flex;"><span>        sigma <span style="color:#f92672">=</span> (p <span style="color:#f92672">*</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> p)) <span style="color:#f92672">**</span> <span style="color:#ae81ff">0.5</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># for bernoulli rv sigma is less than for normal</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># so it&#39;s better to increase N to get similar power</span>
</span></span><span style="display:flex;"><span>        N <span style="color:#f92672">*=</span> int((sigma <span style="color:#f92672">/</span> p) <span style="color:#f92672">**</span> <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(n_iterations):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> metric <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;normal&#34;</span>:
</span></span><span style="display:flex;"><span>            x <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>normal(mu, sigma, N)
</span></span><span style="display:flex;"><span>            y <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>normal(mu<span style="color:#f92672">+</span>eff, sigma, N)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            x <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>choice(a<span style="color:#f92672">=</span>[<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>], size<span style="color:#f92672">=</span>N, replace<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>, p<span style="color:#f92672">=</span>[<span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> p, p])
</span></span><span style="display:flex;"><span>            y <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>choice(a<span style="color:#f92672">=</span>[<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>], size<span style="color:#f92672">=</span>N, replace<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>, p<span style="color:#f92672">=</span>[<span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> p<span style="color:#f92672">*</span>(<span style="color:#ae81ff">1</span><span style="color:#f92672">+</span>eff), p<span style="color:#f92672">*</span>(<span style="color:#ae81ff">1</span><span style="color:#f92672">+</span>eff)])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        size <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>arange(<span style="color:#ae81ff">1</span>, N <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        diff <span style="color:#f92672">=</span> (np<span style="color:#f92672">.</span>cumsum(y) <span style="color:#f92672">/</span> size) <span style="color:#f92672">-</span> (np<span style="color:#f92672">.</span>cumsum(x) <span style="color:#f92672">/</span> size)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        test <span style="color:#f92672">=</span> gavi<span style="color:#f92672">.</span>AlwaysValidInference(size<span style="color:#f92672">=</span>size, sigma2<span style="color:#f92672">=</span>sigma<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span>, estimate<span style="color:#f92672">=</span>diff, alpha<span style="color:#f92672">=</span>alpha)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        itermittent_analyses <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>linspace(N<span style="color:#f92672">/</span><span style="color:#ae81ff">10</span>, N, <span style="color:#ae81ff">10</span>)<span style="color:#f92672">.</span>astype(int) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        z_score <span style="color:#f92672">=</span> diff[itermittent_analyses] <span style="color:#f92672">/</span> np<span style="color:#f92672">.</span>sqrt(<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> sigma <span style="color:#f92672">**</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">/</span> size[itermittent_analyses])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        result[<span style="color:#e6db74">&#39;No_Seq&#39;</span>]<span style="color:#f92672">.</span>append(N <span style="color:#66d9ef">if</span> z_score[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">&gt;</span> norm<span style="color:#f92672">.</span>ppf(<span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> alpha) <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">None</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> sampling <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;accurate&#34;</span>:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            result[<span style="color:#e6db74">&#39;GAVI&#39;</span>]<span style="color:#f92672">.</span>append(stops_at(test<span style="color:#f92672">.</span>GAVI(), size))
</span></span><span style="display:flex;"><span>            result[<span style="color:#e6db74">&#39;mSPRT&#39;</span>]<span style="color:#f92672">.</span>append(stops_at(test<span style="color:#f92672">.</span>mSPRT(), size))
</span></span><span style="display:flex;"><span>            result[<span style="color:#e6db74">&#39;StatSig_SPRT&#39;</span>]<span style="color:#f92672">.</span>append(stops_at(test<span style="color:#f92672">.</span>StatSig_SPRT(), size))
</span></span><span style="display:flex;"><span>            result[<span style="color:#e6db74">&#39;StatSig_v1&#39;</span>]<span style="color:#f92672">.</span>append(stops_at(test<span style="color:#f92672">.</span>statsig_alpha_corrected_v1(), size))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            result[<span style="color:#e6db74">&#39;GST_linear&#39;</span>]<span style="color:#f92672">.</span>append(stops_at(z_score <span style="color:#f92672">&gt;</span> gst_linear, size[itermittent_analyses]))
</span></span><span style="display:flex;"><span>            result[<span style="color:#e6db74">&#39;GST_quadratic&#39;</span>]<span style="color:#f92672">.</span>append(stops_at(z_score <span style="color:#f92672">&gt;</span> gst_quadratic, size[itermittent_analyses]))
</span></span><span style="display:flex;"><span>            result[<span style="color:#e6db74">&#39;GST_cubic&#39;</span>]<span style="color:#f92672">.</span>append(stops_at(z_score <span style="color:#f92672">&gt;</span> gst_cubic, size[itermittent_analyses]))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">elif</span> sampling <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;undersampled&#34;</span>:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            result[<span style="color:#e6db74">&#39;GAVI&#39;</span>]<span style="color:#f92672">.</span>append(stops_at(test<span style="color:#f92672">.</span>GAVI(phi<span style="color:#f92672">=</span>N<span style="color:#f92672">*</span><span style="color:#ae81ff">7</span><span style="color:#f92672">/</span><span style="color:#ae81ff">5</span>), size))
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># undersampling is the case, when the effect is larger than expected</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># so let&#39;s say effect ~ 7/5 times larger, 4 * (5/7)^2 ~ 2</span>
</span></span><span style="display:flex;"><span>            result[<span style="color:#e6db74">&#39;mSPRT&#39;</span>]<span style="color:#f92672">.</span>append(stops_at(test<span style="color:#f92672">.</span>mSPRT(phi<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> sigma<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">/</span> diff<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span>), size))
</span></span><span style="display:flex;"><span>            result[<span style="color:#e6db74">&#39;StatSig_SPRT&#39;</span>]<span style="color:#f92672">.</span>append(stops_at(test<span style="color:#f92672">.</span>StatSig_SPRT(), size))
</span></span><span style="display:flex;"><span>            result[<span style="color:#e6db74">&#39;StatSig_v1&#39;</span>]<span style="color:#f92672">.</span>append(stops_at(test<span style="color:#f92672">.</span>statsig_alpha_corrected_v1(N<span style="color:#f92672">=</span>N<span style="color:#f92672">*</span><span style="color:#ae81ff">7</span><span style="color:#f92672">/</span><span style="color:#ae81ff">5</span>), size))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            result[<span style="color:#e6db74">&#39;GST_linear&#39;</span>]<span style="color:#f92672">.</span>append(stops_at(z_score <span style="color:#f92672">&gt;</span> gst_linear_undersampled, size[itermittent_analyses]))
</span></span><span style="display:flex;"><span>            result[<span style="color:#e6db74">&#39;GST_quadratic&#39;</span>]<span style="color:#f92672">.</span>append(stops_at(z_score <span style="color:#f92672">&gt;</span> gst_quadratic_undersampled, size[itermittent_analyses]))
</span></span><span style="display:flex;"><span>            result[<span style="color:#e6db74">&#39;GST_cubic&#39;</span>]<span style="color:#f92672">.</span>append(stops_at(z_score <span style="color:#f92672">&gt;</span> gst_cubic_undersampled, size[itermittent_analyses]))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">elif</span> sampling <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;oversampled&#34;</span>:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            result[<span style="color:#e6db74">&#39;GAVI&#39;</span>]<span style="color:#f92672">.</span>append(stops_at(test<span style="color:#f92672">.</span>GAVI(phi<span style="color:#f92672">=</span>N<span style="color:#f92672">*</span><span style="color:#ae81ff">7</span><span style="color:#f92672">/</span><span style="color:#ae81ff">10</span>), size))
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># oversmapling is the case, when the effect is lower than expected</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># so let&#39;s say effect ~ 7/10 times lower, 4 * (7/10)^2 ~ 8</span>
</span></span><span style="display:flex;"><span>            result[<span style="color:#e6db74">&#39;mSPRT&#39;</span>]<span style="color:#f92672">.</span>append(stops_at(test<span style="color:#f92672">.</span>mSPRT(phi<span style="color:#f92672">=</span><span style="color:#ae81ff">8</span> <span style="color:#f92672">*</span> sigma<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">/</span> diff<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span>), size))
</span></span><span style="display:flex;"><span>            result[<span style="color:#e6db74">&#39;StatSig_SPRT&#39;</span>]<span style="color:#f92672">.</span>append(stops_at(test<span style="color:#f92672">.</span>StatSig_SPRT(), size))
</span></span><span style="display:flex;"><span>            result[<span style="color:#e6db74">&#39;StatSig_v1&#39;</span>]<span style="color:#f92672">.</span>append(stops_at(test<span style="color:#f92672">.</span>statsig_alpha_corrected_v1(N<span style="color:#f92672">=</span>N<span style="color:#f92672">*</span><span style="color:#ae81ff">7</span><span style="color:#f92672">/</span><span style="color:#ae81ff">10</span>), size))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            result[<span style="color:#e6db74">&#39;GST_linear&#39;</span>]<span style="color:#f92672">.</span>append(stops_at(z_score <span style="color:#f92672">&gt;</span> gst_linear_oversampled, size[itermittent_analyses]))
</span></span><span style="display:flex;"><span>            result[<span style="color:#e6db74">&#39;GST_quadratic&#39;</span>]<span style="color:#f92672">.</span>append(stops_at(z_score <span style="color:#f92672">&gt;</span> gst_quadratic_oversampled, size[itermittent_analyses]))
</span></span><span style="display:flex;"><span>            result[<span style="color:#e6db74">&#39;GST_cubic&#39;</span>]<span style="color:#f92672">.</span>append(stops_at(z_score <span style="color:#f92672">&gt;</span> gst_cubic_oversampled, size[itermittent_analyses]))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">ValueError</span>(<span style="color:#e6db74">&#34;Unknown sampling method&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># remove StatSig_v1 from Power comparison</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> aa_test:
</span></span><span style="display:flex;"><span>        result<span style="color:#f92672">.</span>pop(<span style="color:#e6db74">&#39;StatSig_v1&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    df <span style="color:#f92672">=</span> pd<span style="color:#f92672">.</span>DataFrame(result)<span style="color:#f92672">.</span>agg([<span style="color:#e6db74">&#34;count&#34;</span>, <span style="color:#e6db74">&#34;median&#34;</span>])<span style="color:#f92672">.</span>T<span style="color:#f92672">.</span>assign(
</span></span><span style="display:flex;"><span>          PositiveRate<span style="color:#f92672">=</span><span style="color:#66d9ef">lambda</span> x: (x[<span style="color:#e6db74">&#34;count&#34;</span>] <span style="color:#f92672">/</span> n_iterations)<span style="color:#f92672">.</span>round(<span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>        )<span style="color:#f92672">.</span>assign(
</span></span><span style="display:flex;"><span>            SampleSize<span style="color:#f92672">=</span><span style="color:#66d9ef">lambda</span> x: x[<span style="color:#e6db74">&#34;median&#34;</span>]<span style="color:#f92672">.</span>astype(int)
</span></span><span style="display:flex;"><span>        )[[<span style="color:#e6db74">&#34;PositiveRate&#34;</span>, <span style="color:#e6db74">&#34;SampleSize&#34;</span>]]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> df
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">plot_positive_rate</span>(
</span></span><span style="display:flex;"><span>    df: pd<span style="color:#f92672">.</span>DataFrame,
</span></span><span style="display:flex;"><span>    aa_test: bool<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>,
</span></span><span style="display:flex;"><span>    sampling: str<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    fig <span style="color:#f92672">=</span> go<span style="color:#f92672">.</span>Figure()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> aa_test:
</span></span><span style="display:flex;"><span>        error_const <span style="color:#f92672">=</span> round(<span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> (alpha <span style="color:#f92672">*</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> alpha) <span style="color:#f92672">/</span> n_iterations) <span style="color:#f92672">**</span> <span style="color:#ae81ff">0.5</span>, <span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        error_array <span style="color:#f92672">=</span> round(<span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> (df[<span style="color:#e6db74">&#34;PositiveRate&#34;</span>] <span style="color:#f92672">*</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> df[<span style="color:#e6db74">&#34;PositiveRate&#34;</span>]) <span style="color:#f92672">/</span> n_iterations) <span style="color:#f92672">**</span> <span style="color:#ae81ff">0.5</span>, <span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    fig<span style="color:#f92672">.</span>add_trace(go<span style="color:#f92672">.</span>Bar(
</span></span><span style="display:flex;"><span>        x<span style="color:#f92672">=</span>df<span style="color:#f92672">.</span>index,
</span></span><span style="display:flex;"><span>        y<span style="color:#f92672">=</span>df[<span style="color:#e6db74">&#34;PositiveRate&#34;</span>],
</span></span><span style="display:flex;"><span>        marker_color<span style="color:#f92672">=</span>next(palette),
</span></span><span style="display:flex;"><span>        error_y<span style="color:#f92672">=</span>dict(type<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;constant&#39;</span>, value<span style="color:#f92672">=</span>error_const) <span style="color:#66d9ef">if</span> aa_test <span style="color:#66d9ef">else</span> dict(type<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;data&#39;</span>, array<span style="color:#f92672">=</span>error_array),
</span></span><span style="display:flex;"><span>    ))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> aa_test:
</span></span><span style="display:flex;"><span>        fig<span style="color:#f92672">.</span>add_hline(
</span></span><span style="display:flex;"><span>            y<span style="color:#f92672">=</span><span style="color:#ae81ff">0.05</span>,
</span></span><span style="display:flex;"><span>            line_dash<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;dot&#34;</span>,
</span></span><span style="display:flex;"><span>            annotation_text<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;designed Type I error rate&#34;</span>,
</span></span><span style="display:flex;"><span>            annotation_position<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;top right&#34;</span>
</span></span><span style="display:flex;"><span>        )
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    title <span style="color:#f92672">=</span> (
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span><span style="color:#e6db74">&#39;Correctness&#39;</span> <span style="color:#66d9ef">if</span> aa_test <span style="color:#66d9ef">else</span> <span style="color:#e6db74">&#39;Power&#39;</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> of&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span><span style="color:#e6db74">&#39; &#39;</span> <span style="color:#f92672">+</span> sampling <span style="color:#66d9ef">if</span> sampling <span style="color:#66d9ef">else</span> <span style="color:#e6db74">&#39;&#39;</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> Sequential Testing Design&#34;</span>
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    fig<span style="color:#f92672">.</span>update_layout(
</span></span><span style="display:flex;"><span>        yaxis_title<span style="color:#f92672">=</span><span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>str(<span style="color:#f92672">not</span> aa_test)<span style="color:#e6db74">}</span><span style="color:#e6db74"> Positive Rate&#34;</span>,
</span></span><span style="display:flex;"><span>        title<span style="color:#f92672">=</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;x&#34;</span>: <span style="color:#ae81ff">0.5</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;text&#34;</span>: title,
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        hovermode<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;x&#34;</span>,
</span></span><span style="display:flex;"><span>        template<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;plotly_dark&#34;</span>,
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    fig<span style="color:#f92672">.</span>write_json(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>title<span style="color:#f92672">.</span>replace(<span style="color:#e6db74">&#39; &#39;</span>, <span style="color:#e6db74">&#39;-&#39;</span>)<span style="color:#f92672">.</span>lower()<span style="color:#e6db74">}</span><span style="color:#e6db74">.json&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    fig<span style="color:#f92672">.</span>show()
</span></span></code></pre></div></details>
<h3 id="continuous-variable">Continuous Variable<a hidden class="anchor" aria-hidden="true" href="#continuous-variable">#</a></h3>
<p>As you can see for GST bounds are pre-calculated for the necessary intermittent analyses number that were expected to and in fact take place.
We calculate bounds for 10 intermittent analyses scenario, in addition considering over- and under- sampling designs.</p>
<details>
<summary>Code</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>gst_linear_undersampled <span style="color:#f92672">=</span> gatsby<span style="color:#f92672">.</span>GST(actual<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>, expected<span style="color:#f92672">=</span><span style="color:#ae81ff">14</span>, iuse<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>, phi<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>, alpha<span style="color:#f92672">=</span>alpha)
</span></span><span style="display:flex;"><span>gst_quadratic_undersampled <span style="color:#f92672">=</span> gatsby<span style="color:#f92672">.</span>GST(actual<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>, expected<span style="color:#f92672">=</span><span style="color:#ae81ff">14</span>, iuse<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>, phi<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>, alpha<span style="color:#f92672">=</span>alpha)
</span></span><span style="display:flex;"><span>gst_cubic_undersampled <span style="color:#f92672">=</span> gatsby<span style="color:#f92672">.</span>GST(actual<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>, expected<span style="color:#f92672">=</span><span style="color:#ae81ff">14</span>, iuse<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>, phi<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>, alpha<span style="color:#f92672">=</span>alpha)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>gst_linear_oversampled <span style="color:#f92672">=</span> gatsby<span style="color:#f92672">.</span>GST(actual<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>, expected<span style="color:#f92672">=</span><span style="color:#ae81ff">7</span>, iuse<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>, phi<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>, alpha<span style="color:#f92672">=</span>alpha)
</span></span><span style="display:flex;"><span>gst_quadratic_oversampled <span style="color:#f92672">=</span> gatsby<span style="color:#f92672">.</span>GST(actual<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>, expected<span style="color:#f92672">=</span><span style="color:#ae81ff">7</span>, iuse<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>, phi<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>, alpha<span style="color:#f92672">=</span>alpha)
</span></span><span style="display:flex;"><span>gst_cubic_oversampled <span style="color:#f92672">=</span> gatsby<span style="color:#f92672">.</span>GST(actual<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>, expected<span style="color:#f92672">=</span><span style="color:#ae81ff">7</span>, iuse<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>, phi<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>, alpha<span style="color:#f92672">=</span>alpha)
</span></span></code></pre></div></details>
<h4 id="false-positives">False Positives<a hidden class="anchor" aria-hidden="true" href="#false-positives">#</a></h4>
<details>
<summary>Code</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>df <span style="color:#f92672">=</span> monte_carlo(aa_test<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
</span></span><span style="display:flex;"><span>df
</span></span></code></pre></div></details>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
<p></style></p>
<table>
<thead>
<tr>
<th></th>
<th>PositiveRate</th>
<th>SampleSize</th>
</tr>
</thead>
<tbody>
<tr>
<td>No_Seq</td>
<td>0.051</td>
<td>500</td>
</tr>
<tr>
<td>GAVI</td>
<td>0.018</td>
<td>221</td>
</tr>
<tr>
<td>mSPRT</td>
<td>0.048</td>
<td>38</td>
</tr>
<tr>
<td>StatSig_SPRT</td>
<td>0.026</td>
<td>43</td>
</tr>
<tr>
<td>StatSig_v1</td>
<td>0.074</td>
<td>421</td>
</tr>
<tr>
<td>GST_linear</td>
<td>0.051</td>
<td>300</td>
</tr>
<tr>
<td>GST_quadratic</td>
<td>0.050</td>
<td>400</td>
</tr>
<tr>
<td>GST_cubic</td>
<td>0.051</td>
<td>400</td>
</tr>
</tbody>
</table>
</div>
<details>
<summary>Code</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>plot_positive_rate(df, aa_test<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
</span></span></code></pre></div></details>


<div id="plotly-002"></div>

<script>
  Plotly.newPlot(document.getElementById("plotly-002"), {"data":[{"error_y":{"type":"constant","value":0.002},"marker":{"color":"rgba(171, 99, 250, 0.5)"},"type":"bar","x":["No_Seq","GAVI","mSPRT","StatSig_SPRT","StatSig_v1","GST_linear","GST_quadratic","GST_cubic"],"y":[0.05,0.018,0.049,0.026,0.073,0.051,0.051,0.05]}],"layout":{"annotations":[{"showarrow":false,"text":"designed Type I error rate","x":1,"xanchor":"right","xref":"x domain","y":0.05,"yanchor":"bottom","yref":"y"}],"hovermode":"x","shapes":[{"line":{"dash":"dot"},"type":"line","x0":0,"x1":1,"xref":"x domain","y0":0.05,"y1":0.05,"yref":"y"}],"template":{"data":{"bar":[{"error_x":{"color":"#f2f5fa"},"error_y":{"color":"#f2f5fa"},"marker":{"line":{"color":"rgb(17,17,17)","width":0.5},"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"bar"}],"barpolar":[{"marker":{"line":{"color":"rgb(17,17,17)","width":0.5},"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"barpolar"}],"carpet":[{"aaxis":{"endlinecolor":"#A2B1C6","gridcolor":"#506784","linecolor":"#506784","minorgridcolor":"#506784","startlinecolor":"#A2B1C6"},"baxis":{"endlinecolor":"#A2B1C6","gridcolor":"#506784","linecolor":"#506784","minorgridcolor":"#506784","startlinecolor":"#A2B1C6"},"type":"carpet"}],"choropleth":[{"colorbar":{"outlinewidth":0,"ticks":""},"type":"choropleth"}],"contour":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"contour"}],"contourcarpet":[{"colorbar":{"outlinewidth":0,"ticks":""},"type":"contourcarpet"}],"heatmap":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"heatmap"}],"heatmapgl":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"heatmapgl"}],"histogram":[{"marker":{"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"histogram"}],"histogram2d":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"histogram2d"}],"histogram2dcontour":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"histogram2dcontour"}],"mesh3d":[{"colorbar":{"outlinewidth":0,"ticks":""},"type":"mesh3d"}],"parcoords":[{"line":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"parcoords"}],"pie":[{"automargin":true,"type":"pie"}],"scatter":[{"marker":{"line":{"color":"#283442"}},"type":"scatter"}],"scatter3d":[{"line":{"colorbar":{"outlinewidth":0,"ticks":""}},"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scatter3d"}],"scattercarpet":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scattercarpet"}],"scattergeo":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scattergeo"}],"scattergl":[{"marker":{"line":{"color":"#283442"}},"type":"scattergl"}],"scattermapbox":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scattermapbox"}],"scatterpolar":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scatterpolar"}],"scatterpolargl":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scatterpolargl"}],"scatterternary":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scatterternary"}],"surface":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"surface"}],"table":[{"cells":{"fill":{"color":"#506784"},"line":{"color":"rgb(17,17,17)"}},"header":{"fill":{"color":"#2a3f5f"},"line":{"color":"rgb(17,17,17)"}},"type":"table"}]},"layout":{"annotationdefaults":{"arrowcolor":"#f2f5fa","arrowhead":0,"arrowwidth":1},"autotypenumbers":"strict","coloraxis":{"colorbar":{"outlinewidth":0,"ticks":""}},"colorscale":{"diverging":[[0,"#8e0152"],[0.1,"#c51b7d"],[0.2,"#de77ae"],[0.3,"#f1b6da"],[0.4,"#fde0ef"],[0.5,"#f7f7f7"],[0.6,"#e6f5d0"],[0.7,"#b8e186"],[0.8,"#7fbc41"],[0.9,"#4d9221"],[1,"#276419"]],"sequential":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"sequentialminus":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]]},"colorway":["#636efa","#EF553B","#00cc96","#ab63fa","#FFA15A","#19d3f3","#FF6692","#B6E880","#FF97FF","#FECB52"],"font":{"color":"#f2f5fa"},"geo":{"bgcolor":"rgb(17,17,17)","lakecolor":"rgb(17,17,17)","landcolor":"rgb(17,17,17)","showlakes":true,"showland":true,"subunitcolor":"#506784"},"hoverlabel":{"align":"left"},"hovermode":"closest","mapbox":{"style":"dark"},"paper_bgcolor":"rgb(17,17,17)","plot_bgcolor":"rgb(17,17,17)","polar":{"angularaxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""},"bgcolor":"rgb(17,17,17)","radialaxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""}},"scene":{"xaxis":{"backgroundcolor":"rgb(17,17,17)","gridcolor":"#506784","gridwidth":2,"linecolor":"#506784","showbackground":true,"ticks":"","zerolinecolor":"#C8D4E3"},"yaxis":{"backgroundcolor":"rgb(17,17,17)","gridcolor":"#506784","gridwidth":2,"linecolor":"#506784","showbackground":true,"ticks":"","zerolinecolor":"#C8D4E3"},"zaxis":{"backgroundcolor":"rgb(17,17,17)","gridcolor":"#506784","gridwidth":2,"linecolor":"#506784","showbackground":true,"ticks":"","zerolinecolor":"#C8D4E3"}},"shapedefaults":{"line":{"color":"#f2f5fa"}},"sliderdefaults":{"bgcolor":"#C8D4E3","bordercolor":"rgb(17,17,17)","borderwidth":1,"tickwidth":0},"ternary":{"aaxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""},"baxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""},"bgcolor":"rgb(17,17,17)","caxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""}},"title":{"x":0.05},"updatemenudefaults":{"bgcolor":"#506784","borderwidth":0},"xaxis":{"automargin":true,"gridcolor":"#283442","linecolor":"#506784","ticks":"","title":{"standoff":15},"zerolinecolor":"#283442","zerolinewidth":2},"yaxis":{"automargin":true,"gridcolor":"#283442","linecolor":"#506784","ticks":"","title":{"standoff":15},"zerolinecolor":"#283442","zerolinewidth":2}}},"title":{"text":"Correctness of Sequential Testing Design","x":0.5},"yaxis":{"title":{"text":"False Positive Rate"}}}});
</script>
<p>As it immediately comes clear: StatSig v1 correction was a flaw, all the other methods are targeting $\alpha$ as needed, however out of AVI it&rsquo;s only mSPRT that gives high enough level, the rest of them make fewer false positives what usually is a sign of lower statistical power, we will see it later.</p>
<details>
<summary>Code</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>monte_carlo(aa_test<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>, sampling<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;undersampled&#34;</span>)
</span></span></code></pre></div></details>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
<p></style></p>
<table>
<thead>
<tr>
<th></th>
<th>PositiveRate</th>
<th>SampleSize</th>
</tr>
</thead>
<tbody>
<tr>
<td>No_Seq</td>
<td>0.050</td>
<td>500</td>
</tr>
<tr>
<td>GAVI</td>
<td>0.014</td>
<td>253</td>
</tr>
<tr>
<td>mSPRT</td>
<td>0.043</td>
<td>38</td>
</tr>
<tr>
<td>StatSig_SPRT</td>
<td>0.026</td>
<td>41</td>
</tr>
<tr>
<td>StatSig_v1</td>
<td>0.015</td>
<td>451</td>
</tr>
<tr>
<td>GST_linear</td>
<td>0.047</td>
<td>350</td>
</tr>
<tr>
<td>GST_quadratic</td>
<td>0.046</td>
<td>500</td>
</tr>
<tr>
<td>GST_cubic</td>
<td>0.045</td>
<td>500</td>
</tr>
</tbody>
</table>
</div>
<details>
<summary>Code</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>df <span style="color:#f92672">=</span> monte_carlo(aa_test<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>, sampling<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;oversampled&#34;</span>)
</span></span><span style="display:flex;"><span>df
</span></span></code></pre></div></details>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
<p></style></p>
<table>
<thead>
<tr>
<th></th>
<th>PositiveRate</th>
<th>SampleSize</th>
</tr>
</thead>
<tbody>
<tr>
<td>No_Seq</td>
<td>0.051</td>
<td>500</td>
</tr>
<tr>
<td>GAVI</td>
<td>0.021</td>
<td>189</td>
</tr>
<tr>
<td>mSPRT</td>
<td>0.046</td>
<td>35</td>
</tr>
<tr>
<td>StatSig_SPRT</td>
<td>0.027</td>
<td>36</td>
</tr>
<tr>
<td>StatSig_v1</td>
<td>0.187</td>
<td>378</td>
</tr>
<tr>
<td>GST_linear</td>
<td>0.065</td>
<td>250</td>
</tr>
<tr>
<td>GST_quadratic</td>
<td>0.072</td>
<td>300</td>
</tr>
<tr>
<td>GST_cubic</td>
<td>0.077</td>
<td>350</td>
</tr>
</tbody>
</table>
</div>
<details>
<summary>Code</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>plot_positive_rate(df, aa_test<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>, sampling<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;oversampled&#34;</span>)
</span></span></code></pre></div></details>


<div id="plotly-003"></div>

<script>
  Plotly.newPlot(document.getElementById("plotly-003"), {"data":[{"error_y":{"type":"constant","value":0.002},"marker":{"color":"rgba(255, 161, 90, 0.5)"},"type":"bar","x":["No_Seq","GAVI","mSPRT","StatSig_SPRT","StatSig_v1","GST_linear","GST_quadratic","GST_cubic"],"y":[0.052,0.021,0.046,0.027,0.187,0.064,0.072,0.077]}],"layout":{"annotations":[{"showarrow":false,"text":"designed Type I error rate","x":1,"xanchor":"right","xref":"x domain","y":0.05,"yanchor":"bottom","yref":"y"}],"hovermode":"x","shapes":[{"line":{"dash":"dot"},"type":"line","x0":0,"x1":1,"xref":"x domain","y0":0.05,"y1":0.05,"yref":"y"}],"template":{"data":{"bar":[{"error_x":{"color":"#f2f5fa"},"error_y":{"color":"#f2f5fa"},"marker":{"line":{"color":"rgb(17,17,17)","width":0.5},"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"bar"}],"barpolar":[{"marker":{"line":{"color":"rgb(17,17,17)","width":0.5},"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"barpolar"}],"carpet":[{"aaxis":{"endlinecolor":"#A2B1C6","gridcolor":"#506784","linecolor":"#506784","minorgridcolor":"#506784","startlinecolor":"#A2B1C6"},"baxis":{"endlinecolor":"#A2B1C6","gridcolor":"#506784","linecolor":"#506784","minorgridcolor":"#506784","startlinecolor":"#A2B1C6"},"type":"carpet"}],"choropleth":[{"colorbar":{"outlinewidth":0,"ticks":""},"type":"choropleth"}],"contour":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"contour"}],"contourcarpet":[{"colorbar":{"outlinewidth":0,"ticks":""},"type":"contourcarpet"}],"heatmap":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"heatmap"}],"heatmapgl":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"heatmapgl"}],"histogram":[{"marker":{"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"histogram"}],"histogram2d":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"histogram2d"}],"histogram2dcontour":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"histogram2dcontour"}],"mesh3d":[{"colorbar":{"outlinewidth":0,"ticks":""},"type":"mesh3d"}],"parcoords":[{"line":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"parcoords"}],"pie":[{"automargin":true,"type":"pie"}],"scatter":[{"marker":{"line":{"color":"#283442"}},"type":"scatter"}],"scatter3d":[{"line":{"colorbar":{"outlinewidth":0,"ticks":""}},"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scatter3d"}],"scattercarpet":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scattercarpet"}],"scattergeo":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scattergeo"}],"scattergl":[{"marker":{"line":{"color":"#283442"}},"type":"scattergl"}],"scattermapbox":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scattermapbox"}],"scatterpolar":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scatterpolar"}],"scatterpolargl":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scatterpolargl"}],"scatterternary":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scatterternary"}],"surface":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"surface"}],"table":[{"cells":{"fill":{"color":"#506784"},"line":{"color":"rgb(17,17,17)"}},"header":{"fill":{"color":"#2a3f5f"},"line":{"color":"rgb(17,17,17)"}},"type":"table"}]},"layout":{"annotationdefaults":{"arrowcolor":"#f2f5fa","arrowhead":0,"arrowwidth":1},"autotypenumbers":"strict","coloraxis":{"colorbar":{"outlinewidth":0,"ticks":""}},"colorscale":{"diverging":[[0,"#8e0152"],[0.1,"#c51b7d"],[0.2,"#de77ae"],[0.3,"#f1b6da"],[0.4,"#fde0ef"],[0.5,"#f7f7f7"],[0.6,"#e6f5d0"],[0.7,"#b8e186"],[0.8,"#7fbc41"],[0.9,"#4d9221"],[1,"#276419"]],"sequential":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"sequentialminus":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]]},"colorway":["#636efa","#EF553B","#00cc96","#ab63fa","#FFA15A","#19d3f3","#FF6692","#B6E880","#FF97FF","#FECB52"],"font":{"color":"#f2f5fa"},"geo":{"bgcolor":"rgb(17,17,17)","lakecolor":"rgb(17,17,17)","landcolor":"rgb(17,17,17)","showlakes":true,"showland":true,"subunitcolor":"#506784"},"hoverlabel":{"align":"left"},"hovermode":"closest","mapbox":{"style":"dark"},"paper_bgcolor":"rgb(17,17,17)","plot_bgcolor":"rgb(17,17,17)","polar":{"angularaxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""},"bgcolor":"rgb(17,17,17)","radialaxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""}},"scene":{"xaxis":{"backgroundcolor":"rgb(17,17,17)","gridcolor":"#506784","gridwidth":2,"linecolor":"#506784","showbackground":true,"ticks":"","zerolinecolor":"#C8D4E3"},"yaxis":{"backgroundcolor":"rgb(17,17,17)","gridcolor":"#506784","gridwidth":2,"linecolor":"#506784","showbackground":true,"ticks":"","zerolinecolor":"#C8D4E3"},"zaxis":{"backgroundcolor":"rgb(17,17,17)","gridcolor":"#506784","gridwidth":2,"linecolor":"#506784","showbackground":true,"ticks":"","zerolinecolor":"#C8D4E3"}},"shapedefaults":{"line":{"color":"#f2f5fa"}},"sliderdefaults":{"bgcolor":"#C8D4E3","bordercolor":"rgb(17,17,17)","borderwidth":1,"tickwidth":0},"ternary":{"aaxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""},"baxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""},"bgcolor":"rgb(17,17,17)","caxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""}},"title":{"x":0.05},"updatemenudefaults":{"bgcolor":"#506784","borderwidth":0},"xaxis":{"automargin":true,"gridcolor":"#283442","linecolor":"#506784","ticks":"","title":{"standoff":15},"zerolinecolor":"#283442","zerolinewidth":2},"yaxis":{"automargin":true,"gridcolor":"#283442","linecolor":"#506784","ticks":"","title":{"standoff":15},"zerolinecolor":"#283442","zerolinewidth":2}}},"title":{"text":"Correctness of oversampled Sequential Testing Design","x":0.5},"yaxis":{"title":{"text":"False Positive Rate"}}}});
</script>
<ol>
<li>Over-sampling is a tough cookie for <code>GST</code>, in such a case GST doesn&rsquo;t work correctly, it inflates Type I error, so it&rsquo;s important to note the difference here between <code>AVI</code> and <code>GST</code>, the latter one is not designed to handle over-sampling</li>
<li>StatSig distinguished itself: their v1 version suffers more than any other method form both under- and over- sampling, while on the other flip their SPRT implementation is totally resistant to under- and over- sampling and if identifies the positive, it does it quickly, most likely it will be underpowered though.</li>
<li>As of now mSPRT seems to be the best choice as it identifies the differences so fast and just a little less often than it should.</li>
</ol>
<h4 id="true-positives">True Positives<a hidden class="anchor" aria-hidden="true" href="#true-positives">#</a></h4>
<p>It&rsquo;s time to compare the power of different methods, I&rsquo;m not going to consider StatSig Alpha corrected version anymore as it&rsquo;s not a valid procedure</p>
<details>
<summary>Code</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>df <span style="color:#f92672">=</span> monte_carlo(aa_test<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>)
</span></span><span style="display:flex;"><span>df
</span></span></code></pre></div></details>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
<p></style></p>
<table>
<thead>
<tr>
<th></th>
<th>PositiveRate</th>
<th>SampleSize</th>
</tr>
</thead>
<tbody>
<tr>
<td>No_Seq</td>
<td>0.474</td>
<td>500</td>
</tr>
<tr>
<td>GAVI</td>
<td>0.222</td>
<td>285</td>
</tr>
<tr>
<td>mSPRT</td>
<td>0.268</td>
<td>202</td>
</tr>
<tr>
<td>StatSig_SPRT</td>
<td>0.188</td>
<td>230</td>
</tr>
<tr>
<td>GST_linear</td>
<td>0.409</td>
<td>300</td>
</tr>
<tr>
<td>GST_quadratic</td>
<td>0.445</td>
<td>350</td>
</tr>
<tr>
<td>GST_cubic</td>
<td>0.459</td>
<td>400</td>
</tr>
</tbody>
</table>
</div>
<details>
<summary>Code</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>plot_positive_rate(df, aa_test<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>)
</span></span></code></pre></div></details>


<div id="plotly-004"></div>

<script>
  Plotly.newPlot(document.getElementById("plotly-004"), {"data":[{"error_y":{"array":[0.005,0.004,0.004,0.004,0.005,0.005,0.005],"type":"data"},"marker":{"color":"rgba(25, 211, 243, 0.5)"},"type":"bar","x":["No_Seq","GAVI","mSPRT","StatSig_SPRT","GST_linear","GST_quadratic","GST_cubic"],"y":[0.478,0.224,0.269,0.189,0.414,0.45,0.462]}],"layout":{"hovermode":"x","template":{"data":{"bar":[{"error_x":{"color":"#f2f5fa"},"error_y":{"color":"#f2f5fa"},"marker":{"line":{"color":"rgb(17,17,17)","width":0.5},"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"bar"}],"barpolar":[{"marker":{"line":{"color":"rgb(17,17,17)","width":0.5},"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"barpolar"}],"carpet":[{"aaxis":{"endlinecolor":"#A2B1C6","gridcolor":"#506784","linecolor":"#506784","minorgridcolor":"#506784","startlinecolor":"#A2B1C6"},"baxis":{"endlinecolor":"#A2B1C6","gridcolor":"#506784","linecolor":"#506784","minorgridcolor":"#506784","startlinecolor":"#A2B1C6"},"type":"carpet"}],"choropleth":[{"colorbar":{"outlinewidth":0,"ticks":""},"type":"choropleth"}],"contour":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"contour"}],"contourcarpet":[{"colorbar":{"outlinewidth":0,"ticks":""},"type":"contourcarpet"}],"heatmap":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"heatmap"}],"heatmapgl":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"heatmapgl"}],"histogram":[{"marker":{"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"histogram"}],"histogram2d":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"histogram2d"}],"histogram2dcontour":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"histogram2dcontour"}],"mesh3d":[{"colorbar":{"outlinewidth":0,"ticks":""},"type":"mesh3d"}],"parcoords":[{"line":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"parcoords"}],"pie":[{"automargin":true,"type":"pie"}],"scatter":[{"marker":{"line":{"color":"#283442"}},"type":"scatter"}],"scatter3d":[{"line":{"colorbar":{"outlinewidth":0,"ticks":""}},"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scatter3d"}],"scattercarpet":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scattercarpet"}],"scattergeo":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scattergeo"}],"scattergl":[{"marker":{"line":{"color":"#283442"}},"type":"scattergl"}],"scattermapbox":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scattermapbox"}],"scatterpolar":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scatterpolar"}],"scatterpolargl":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scatterpolargl"}],"scatterternary":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scatterternary"}],"surface":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"surface"}],"table":[{"cells":{"fill":{"color":"#506784"},"line":{"color":"rgb(17,17,17)"}},"header":{"fill":{"color":"#2a3f5f"},"line":{"color":"rgb(17,17,17)"}},"type":"table"}]},"layout":{"annotationdefaults":{"arrowcolor":"#f2f5fa","arrowhead":0,"arrowwidth":1},"autotypenumbers":"strict","coloraxis":{"colorbar":{"outlinewidth":0,"ticks":""}},"colorscale":{"diverging":[[0,"#8e0152"],[0.1,"#c51b7d"],[0.2,"#de77ae"],[0.3,"#f1b6da"],[0.4,"#fde0ef"],[0.5,"#f7f7f7"],[0.6,"#e6f5d0"],[0.7,"#b8e186"],[0.8,"#7fbc41"],[0.9,"#4d9221"],[1,"#276419"]],"sequential":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"sequentialminus":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]]},"colorway":["#636efa","#EF553B","#00cc96","#ab63fa","#FFA15A","#19d3f3","#FF6692","#B6E880","#FF97FF","#FECB52"],"font":{"color":"#f2f5fa"},"geo":{"bgcolor":"rgb(17,17,17)","lakecolor":"rgb(17,17,17)","landcolor":"rgb(17,17,17)","showlakes":true,"showland":true,"subunitcolor":"#506784"},"hoverlabel":{"align":"left"},"hovermode":"closest","mapbox":{"style":"dark"},"paper_bgcolor":"rgb(17,17,17)","plot_bgcolor":"rgb(17,17,17)","polar":{"angularaxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""},"bgcolor":"rgb(17,17,17)","radialaxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""}},"scene":{"xaxis":{"backgroundcolor":"rgb(17,17,17)","gridcolor":"#506784","gridwidth":2,"linecolor":"#506784","showbackground":true,"ticks":"","zerolinecolor":"#C8D4E3"},"yaxis":{"backgroundcolor":"rgb(17,17,17)","gridcolor":"#506784","gridwidth":2,"linecolor":"#506784","showbackground":true,"ticks":"","zerolinecolor":"#C8D4E3"},"zaxis":{"backgroundcolor":"rgb(17,17,17)","gridcolor":"#506784","gridwidth":2,"linecolor":"#506784","showbackground":true,"ticks":"","zerolinecolor":"#C8D4E3"}},"shapedefaults":{"line":{"color":"#f2f5fa"}},"sliderdefaults":{"bgcolor":"#C8D4E3","bordercolor":"rgb(17,17,17)","borderwidth":1,"tickwidth":0},"ternary":{"aaxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""},"baxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""},"bgcolor":"rgb(17,17,17)","caxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""}},"title":{"x":0.05},"updatemenudefaults":{"bgcolor":"#506784","borderwidth":0},"xaxis":{"automargin":true,"gridcolor":"#283442","linecolor":"#506784","ticks":"","title":{"standoff":15},"zerolinecolor":"#283442","zerolinewidth":2},"yaxis":{"automargin":true,"gridcolor":"#283442","linecolor":"#506784","ticks":"","title":{"standoff":15},"zerolinecolor":"#283442","zerolinewidth":2}}},"title":{"text":"Power of Sequential Testing Design","x":0.5},"yaxis":{"title":{"text":"True Positive Rate"}}}});
</script>
<details>
<summary>Code</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>df <span style="color:#f92672">=</span> monte_carlo(aa_test<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>, sampling<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;undersampled&#34;</span>)
</span></span><span style="display:flex;"><span>df
</span></span></code></pre></div></details>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
<p></style></p>
<table>
<thead>
<tr>
<th></th>
<th>PositiveRate</th>
<th>SampleSize</th>
</tr>
</thead>
<tbody>
<tr>
<td>No_Seq</td>
<td>0.478</td>
<td>500</td>
</tr>
<tr>
<td>GAVI</td>
<td>0.211</td>
<td>306</td>
</tr>
<tr>
<td>mSPRT</td>
<td>0.253</td>
<td>210</td>
</tr>
<tr>
<td>StatSig_SPRT</td>
<td>0.190</td>
<td>233</td>
</tr>
<tr>
<td>GST_linear</td>
<td>0.425</td>
<td>350</td>
</tr>
<tr>
<td>GST_quadratic</td>
<td>0.449</td>
<td>450</td>
</tr>
<tr>
<td>GST_cubic</td>
<td>0.455</td>
<td>500</td>
</tr>
</tbody>
</table>
</div>
<details>
<summary>Code</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>plot_positive_rate(df, aa_test<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>, sampling<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;undersampled&#34;</span>)
</span></span></code></pre></div></details>


<div id="plotly-005"></div>

<script>
  Plotly.newPlot(document.getElementById("plotly-005"), {"data":[{"error_y":{"array":[0.005,0.004,0.004,0.004,0.005,0.005,0.005],"type":"data"},"marker":{"color":"rgba(255, 102, 146, 0.5)"},"type":"bar","x":["No_Seq","GAVI","mSPRT","StatSig_SPRT","GST_linear","GST_quadratic","GST_cubic"],"y":[0.476,0.211,0.254,0.19,0.423,0.445,0.452]}],"layout":{"hovermode":"x","template":{"data":{"bar":[{"error_x":{"color":"#f2f5fa"},"error_y":{"color":"#f2f5fa"},"marker":{"line":{"color":"rgb(17,17,17)","width":0.5},"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"bar"}],"barpolar":[{"marker":{"line":{"color":"rgb(17,17,17)","width":0.5},"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"barpolar"}],"carpet":[{"aaxis":{"endlinecolor":"#A2B1C6","gridcolor":"#506784","linecolor":"#506784","minorgridcolor":"#506784","startlinecolor":"#A2B1C6"},"baxis":{"endlinecolor":"#A2B1C6","gridcolor":"#506784","linecolor":"#506784","minorgridcolor":"#506784","startlinecolor":"#A2B1C6"},"type":"carpet"}],"choropleth":[{"colorbar":{"outlinewidth":0,"ticks":""},"type":"choropleth"}],"contour":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"contour"}],"contourcarpet":[{"colorbar":{"outlinewidth":0,"ticks":""},"type":"contourcarpet"}],"heatmap":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"heatmap"}],"heatmapgl":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"heatmapgl"}],"histogram":[{"marker":{"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"histogram"}],"histogram2d":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"histogram2d"}],"histogram2dcontour":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"histogram2dcontour"}],"mesh3d":[{"colorbar":{"outlinewidth":0,"ticks":""},"type":"mesh3d"}],"parcoords":[{"line":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"parcoords"}],"pie":[{"automargin":true,"type":"pie"}],"scatter":[{"marker":{"line":{"color":"#283442"}},"type":"scatter"}],"scatter3d":[{"line":{"colorbar":{"outlinewidth":0,"ticks":""}},"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scatter3d"}],"scattercarpet":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scattercarpet"}],"scattergeo":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scattergeo"}],"scattergl":[{"marker":{"line":{"color":"#283442"}},"type":"scattergl"}],"scattermapbox":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scattermapbox"}],"scatterpolar":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scatterpolar"}],"scatterpolargl":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scatterpolargl"}],"scatterternary":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scatterternary"}],"surface":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"surface"}],"table":[{"cells":{"fill":{"color":"#506784"},"line":{"color":"rgb(17,17,17)"}},"header":{"fill":{"color":"#2a3f5f"},"line":{"color":"rgb(17,17,17)"}},"type":"table"}]},"layout":{"annotationdefaults":{"arrowcolor":"#f2f5fa","arrowhead":0,"arrowwidth":1},"autotypenumbers":"strict","coloraxis":{"colorbar":{"outlinewidth":0,"ticks":""}},"colorscale":{"diverging":[[0,"#8e0152"],[0.1,"#c51b7d"],[0.2,"#de77ae"],[0.3,"#f1b6da"],[0.4,"#fde0ef"],[0.5,"#f7f7f7"],[0.6,"#e6f5d0"],[0.7,"#b8e186"],[0.8,"#7fbc41"],[0.9,"#4d9221"],[1,"#276419"]],"sequential":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"sequentialminus":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]]},"colorway":["#636efa","#EF553B","#00cc96","#ab63fa","#FFA15A","#19d3f3","#FF6692","#B6E880","#FF97FF","#FECB52"],"font":{"color":"#f2f5fa"},"geo":{"bgcolor":"rgb(17,17,17)","lakecolor":"rgb(17,17,17)","landcolor":"rgb(17,17,17)","showlakes":true,"showland":true,"subunitcolor":"#506784"},"hoverlabel":{"align":"left"},"hovermode":"closest","mapbox":{"style":"dark"},"paper_bgcolor":"rgb(17,17,17)","plot_bgcolor":"rgb(17,17,17)","polar":{"angularaxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""},"bgcolor":"rgb(17,17,17)","radialaxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""}},"scene":{"xaxis":{"backgroundcolor":"rgb(17,17,17)","gridcolor":"#506784","gridwidth":2,"linecolor":"#506784","showbackground":true,"ticks":"","zerolinecolor":"#C8D4E3"},"yaxis":{"backgroundcolor":"rgb(17,17,17)","gridcolor":"#506784","gridwidth":2,"linecolor":"#506784","showbackground":true,"ticks":"","zerolinecolor":"#C8D4E3"},"zaxis":{"backgroundcolor":"rgb(17,17,17)","gridcolor":"#506784","gridwidth":2,"linecolor":"#506784","showbackground":true,"ticks":"","zerolinecolor":"#C8D4E3"}},"shapedefaults":{"line":{"color":"#f2f5fa"}},"sliderdefaults":{"bgcolor":"#C8D4E3","bordercolor":"rgb(17,17,17)","borderwidth":1,"tickwidth":0},"ternary":{"aaxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""},"baxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""},"bgcolor":"rgb(17,17,17)","caxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""}},"title":{"x":0.05},"updatemenudefaults":{"bgcolor":"#506784","borderwidth":0},"xaxis":{"automargin":true,"gridcolor":"#283442","linecolor":"#506784","ticks":"","title":{"standoff":15},"zerolinecolor":"#283442","zerolinewidth":2},"yaxis":{"automargin":true,"gridcolor":"#283442","linecolor":"#506784","ticks":"","title":{"standoff":15},"zerolinecolor":"#283442","zerolinewidth":2}}},"title":{"text":"Power of undersampled Sequential Testing Design","x":0.5},"yaxis":{"title":{"text":"True Positive Rate"}}}});
</script>
<details>
<summary>Code</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>monte_carlo(aa_test<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>, sampling<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;oversampled&#34;</span>)
</span></span></code></pre></div></details>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
<p></style></p>
<table>
<thead>
<tr>
<th></th>
<th>PositiveRate</th>
<th>SampleSize</th>
</tr>
</thead>
<tbody>
<tr>
<td>No_Seq</td>
<td>0.476</td>
<td>500</td>
</tr>
<tr>
<td>GAVI</td>
<td>0.236</td>
<td>268</td>
</tr>
<tr>
<td>mSPRT</td>
<td>0.263</td>
<td>208</td>
</tr>
<tr>
<td>StatSig_SPRT</td>
<td>0.190</td>
<td>233</td>
</tr>
<tr>
<td>GST_linear</td>
<td>0.443</td>
<td>300</td>
</tr>
<tr>
<td>GST_quadratic</td>
<td>0.496</td>
<td>300</td>
</tr>
<tr>
<td>GST_cubic</td>
<td>0.519</td>
<td>350</td>
</tr>
</tbody>
</table>
</div>
<p>So, as it comes from bar chart and tables:</p>
<ol>
<li>all <code>AVI</code> (including over-sampled options) are way weaker than even under-sampled GST, so power-wise <code>GST</code> is an unconditional winner</li>
<li>it&rsquo;s appealing that for under-sampled <code>GST</code> the power has just a subtle decline, and even then only for strict spending function (Cubic), providing an increase for permissive spending function (Linear)</li>
<li>Although if <code>AVI</code> rejects null hypothesis it does quicker (the required Sample Size is smaller) than <code>GST</code> on average</li>
</ol>
<h3 id="conversion-rate">Conversion Rate<a hidden class="anchor" aria-hidden="true" href="#conversion-rate">#</a></h3>
<p>In addition to continuous measure, let&rsquo;s consider ratio variable, how the methods work with conversions</p>
<h4 id="false-positives-1">False Positives<a hidden class="anchor" aria-hidden="true" href="#false-positives-1">#</a></h4>
<details>
<summary>Code</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>df <span style="color:#f92672">=</span> monte_carlo(aa_test<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>, metric<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;choice&#34;</span>)
</span></span><span style="display:flex;"><span>df
</span></span></code></pre></div></details>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
<p></style></p>
<table>
<thead>
<tr>
<th></th>
<th>PositiveRate</th>
<th>SampleSize</th>
</tr>
</thead>
<tbody>
<tr>
<td>No_Seq</td>
<td>0.050</td>
<td>4500</td>
</tr>
<tr>
<td>GAVI</td>
<td>0.018</td>
<td>1913</td>
</tr>
<tr>
<td>mSPRT</td>
<td>0.072</td>
<td>88</td>
</tr>
<tr>
<td>StatSig_SPRT</td>
<td>0.044</td>
<td>60</td>
</tr>
<tr>
<td>StatSig_v1</td>
<td>0.074</td>
<td>3796</td>
</tr>
<tr>
<td>GST_linear</td>
<td>0.050</td>
<td>2700</td>
</tr>
<tr>
<td>GST_quadratic</td>
<td>0.049</td>
<td>3600</td>
</tr>
<tr>
<td>GST_cubic</td>
<td>0.049</td>
<td>3600</td>
</tr>
</tbody>
</table>
</div>
<details>
<summary>Code</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>plot_positive_rate(df, aa_test<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>, sampling<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;ratio&#34;</span>)
</span></span></code></pre></div></details>


<div id="plotly-006"></div>

<script>
  Plotly.newPlot(document.getElementById("plotly-006"), {"data":[{"error_y":{"type":"constant","value":0.002},"marker":{"color":"rgba(182, 232, 128, 0.5)"},"type":"bar","x":["No_Seq","GAVI","mSPRT","StatSig_SPRT","StatSig_v1","GST_linear","GST_quadratic","GST_cubic"],"y":[0.051,0.019,0.072,0.044,0.074,0.05,0.049,0.05]}],"layout":{"annotations":[{"showarrow":false,"text":"designed Type I error rate","x":1,"xanchor":"right","xref":"x domain","y":0.05,"yanchor":"bottom","yref":"y"}],"hovermode":"x","shapes":[{"line":{"dash":"dot"},"type":"line","x0":0,"x1":1,"xref":"x domain","y0":0.05,"y1":0.05,"yref":"y"}],"template":{"data":{"bar":[{"error_x":{"color":"#f2f5fa"},"error_y":{"color":"#f2f5fa"},"marker":{"line":{"color":"rgb(17,17,17)","width":0.5},"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"bar"}],"barpolar":[{"marker":{"line":{"color":"rgb(17,17,17)","width":0.5},"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"barpolar"}],"carpet":[{"aaxis":{"endlinecolor":"#A2B1C6","gridcolor":"#506784","linecolor":"#506784","minorgridcolor":"#506784","startlinecolor":"#A2B1C6"},"baxis":{"endlinecolor":"#A2B1C6","gridcolor":"#506784","linecolor":"#506784","minorgridcolor":"#506784","startlinecolor":"#A2B1C6"},"type":"carpet"}],"choropleth":[{"colorbar":{"outlinewidth":0,"ticks":""},"type":"choropleth"}],"contour":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"contour"}],"contourcarpet":[{"colorbar":{"outlinewidth":0,"ticks":""},"type":"contourcarpet"}],"heatmap":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"heatmap"}],"heatmapgl":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"heatmapgl"}],"histogram":[{"marker":{"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"histogram"}],"histogram2d":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"histogram2d"}],"histogram2dcontour":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"histogram2dcontour"}],"mesh3d":[{"colorbar":{"outlinewidth":0,"ticks":""},"type":"mesh3d"}],"parcoords":[{"line":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"parcoords"}],"pie":[{"automargin":true,"type":"pie"}],"scatter":[{"marker":{"line":{"color":"#283442"}},"type":"scatter"}],"scatter3d":[{"line":{"colorbar":{"outlinewidth":0,"ticks":""}},"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scatter3d"}],"scattercarpet":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scattercarpet"}],"scattergeo":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scattergeo"}],"scattergl":[{"marker":{"line":{"color":"#283442"}},"type":"scattergl"}],"scattermapbox":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scattermapbox"}],"scatterpolar":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scatterpolar"}],"scatterpolargl":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scatterpolargl"}],"scatterternary":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scatterternary"}],"surface":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"surface"}],"table":[{"cells":{"fill":{"color":"#506784"},"line":{"color":"rgb(17,17,17)"}},"header":{"fill":{"color":"#2a3f5f"},"line":{"color":"rgb(17,17,17)"}},"type":"table"}]},"layout":{"annotationdefaults":{"arrowcolor":"#f2f5fa","arrowhead":0,"arrowwidth":1},"autotypenumbers":"strict","coloraxis":{"colorbar":{"outlinewidth":0,"ticks":""}},"colorscale":{"diverging":[[0,"#8e0152"],[0.1,"#c51b7d"],[0.2,"#de77ae"],[0.3,"#f1b6da"],[0.4,"#fde0ef"],[0.5,"#f7f7f7"],[0.6,"#e6f5d0"],[0.7,"#b8e186"],[0.8,"#7fbc41"],[0.9,"#4d9221"],[1,"#276419"]],"sequential":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"sequentialminus":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]]},"colorway":["#636efa","#EF553B","#00cc96","#ab63fa","#FFA15A","#19d3f3","#FF6692","#B6E880","#FF97FF","#FECB52"],"font":{"color":"#f2f5fa"},"geo":{"bgcolor":"rgb(17,17,17)","lakecolor":"rgb(17,17,17)","landcolor":"rgb(17,17,17)","showlakes":true,"showland":true,"subunitcolor":"#506784"},"hoverlabel":{"align":"left"},"hovermode":"closest","mapbox":{"style":"dark"},"paper_bgcolor":"rgb(17,17,17)","plot_bgcolor":"rgb(17,17,17)","polar":{"angularaxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""},"bgcolor":"rgb(17,17,17)","radialaxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""}},"scene":{"xaxis":{"backgroundcolor":"rgb(17,17,17)","gridcolor":"#506784","gridwidth":2,"linecolor":"#506784","showbackground":true,"ticks":"","zerolinecolor":"#C8D4E3"},"yaxis":{"backgroundcolor":"rgb(17,17,17)","gridcolor":"#506784","gridwidth":2,"linecolor":"#506784","showbackground":true,"ticks":"","zerolinecolor":"#C8D4E3"},"zaxis":{"backgroundcolor":"rgb(17,17,17)","gridcolor":"#506784","gridwidth":2,"linecolor":"#506784","showbackground":true,"ticks":"","zerolinecolor":"#C8D4E3"}},"shapedefaults":{"line":{"color":"#f2f5fa"}},"sliderdefaults":{"bgcolor":"#C8D4E3","bordercolor":"rgb(17,17,17)","borderwidth":1,"tickwidth":0},"ternary":{"aaxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""},"baxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""},"bgcolor":"rgb(17,17,17)","caxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""}},"title":{"x":0.05},"updatemenudefaults":{"bgcolor":"#506784","borderwidth":0},"xaxis":{"automargin":true,"gridcolor":"#283442","linecolor":"#506784","ticks":"","title":{"standoff":15},"zerolinecolor":"#283442","zerolinewidth":2},"yaxis":{"automargin":true,"gridcolor":"#283442","linecolor":"#506784","ticks":"","title":{"standoff":15},"zerolinecolor":"#283442","zerolinewidth":2}}},"title":{"text":"Correctness of ratio Sequential Testing Design","x":0.5},"yaxis":{"title":{"text":"False Positive Rate"}}}});
</script>
<p>As you see, in addition to StatSig v1 Alpha Correction which is again an outsider, mSPRT approximation is not good enough for Bernoulli random variable, for conversions it&rsquo;s another approach that shall be applied, <code>savvi</code> package might come handy here as it the main purpose the that library - to work with inhomogeneous Bernoulli or Poisson process.
Alternatively, you may use <code>sequential_p_value</code> function from <code>gavi</code> module of <code>seqabpy</code>, it&rsquo;s a valid procedure following the algorithm defined by M. Lindon and A. Malek in <a href="https://openreview.net/pdf?id=a4zg0jiuVi">Anytime-Valid Inference For Multinomial Count Data (2022)</a>, could be a little less powerful though than <code>savvi</code> implementation that follows even more recent articles.</p>
<details>
<summary>Code</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>expected_probs <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0.5</span>, <span style="color:#ae81ff">0.5</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># it&#39;s an asymptotic algorithm, so only numerators are compared</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># assuming the denominators of convesrion are similar like in fair A/B test</span>
</span></span><span style="display:flex;"><span>actual_counts <span style="color:#f92672">=</span> [<span style="color:#ae81ff">156</span>, <span style="color:#ae81ff">212</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;AVI p-value for Conversion: </span><span style="color:#e6db74">{</span>gavi<span style="color:#f92672">.</span>sequential_p_value(actual_counts, expected_probs)<span style="color:#e6db74">:</span><span style="color:#e6db74">.3f</span><span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span></code></pre></div></details>
<pre><code>AVI p-value for Conversion: 0.075
</code></pre>
<details>
<summary>Code</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>df <span style="color:#f92672">=</span> monte_carlo(aa_test<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>, metric<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;choice&#34;</span>, sampling<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;oversampled&#34;</span>)
</span></span><span style="display:flex;"><span>df
</span></span></code></pre></div></details>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
<p></style></p>
<table>
<thead>
<tr>
<th></th>
<th>PositiveRate</th>
<th>SampleSize</th>
</tr>
</thead>
<tbody>
<tr>
<td>No_Seq</td>
<td>0.051</td>
<td>4500</td>
</tr>
<tr>
<td>GAVI</td>
<td>0.022</td>
<td>1620</td>
</tr>
<tr>
<td>mSPRT</td>
<td>0.069</td>
<td>85</td>
</tr>
<tr>
<td>StatSig_SPRT</td>
<td>0.045</td>
<td>61</td>
</tr>
<tr>
<td>StatSig_v1</td>
<td>0.189</td>
<td>3377</td>
</tr>
<tr>
<td>GST_linear</td>
<td>0.064</td>
<td>2250</td>
</tr>
<tr>
<td>GST_quadratic</td>
<td>0.072</td>
<td>2700</td>
</tr>
<tr>
<td>GST_cubic</td>
<td>0.076</td>
<td>3150</td>
</tr>
</tbody>
</table>
</div>
<details>
<summary>Code</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>plot_positive_rate(df, aa_test<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>, sampling<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;oversampled ratio&#34;</span>)
</span></span></code></pre></div></details>


<div id="plotly-007"></div>

<script>
  Plotly.newPlot(document.getElementById("plotly-007"), {"data":[{"error_y":{"type":"constant","value":0.002},"marker":{"color":"rgba(255, 151, 255, 0.5)"},"type":"bar","x":["No_Seq","GAVI","mSPRT","StatSig_SPRT","StatSig_v1","GST_linear","GST_quadratic","GST_cubic"],"y":[0.052,0.023,0.07,0.046,0.19,0.064,0.072,0.076]}],"layout":{"annotations":[{"showarrow":false,"text":"designed Type I error rate","x":1,"xanchor":"right","xref":"x domain","y":0.05,"yanchor":"bottom","yref":"y"}],"hovermode":"x","shapes":[{"line":{"dash":"dot"},"type":"line","x0":0,"x1":1,"xref":"x domain","y0":0.05,"y1":0.05,"yref":"y"}],"template":{"data":{"bar":[{"error_x":{"color":"#f2f5fa"},"error_y":{"color":"#f2f5fa"},"marker":{"line":{"color":"rgb(17,17,17)","width":0.5},"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"bar"}],"barpolar":[{"marker":{"line":{"color":"rgb(17,17,17)","width":0.5},"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"barpolar"}],"carpet":[{"aaxis":{"endlinecolor":"#A2B1C6","gridcolor":"#506784","linecolor":"#506784","minorgridcolor":"#506784","startlinecolor":"#A2B1C6"},"baxis":{"endlinecolor":"#A2B1C6","gridcolor":"#506784","linecolor":"#506784","minorgridcolor":"#506784","startlinecolor":"#A2B1C6"},"type":"carpet"}],"choropleth":[{"colorbar":{"outlinewidth":0,"ticks":""},"type":"choropleth"}],"contour":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"contour"}],"contourcarpet":[{"colorbar":{"outlinewidth":0,"ticks":""},"type":"contourcarpet"}],"heatmap":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"heatmap"}],"heatmapgl":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"heatmapgl"}],"histogram":[{"marker":{"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"histogram"}],"histogram2d":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"histogram2d"}],"histogram2dcontour":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"histogram2dcontour"}],"mesh3d":[{"colorbar":{"outlinewidth":0,"ticks":""},"type":"mesh3d"}],"parcoords":[{"line":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"parcoords"}],"pie":[{"automargin":true,"type":"pie"}],"scatter":[{"marker":{"line":{"color":"#283442"}},"type":"scatter"}],"scatter3d":[{"line":{"colorbar":{"outlinewidth":0,"ticks":""}},"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scatter3d"}],"scattercarpet":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scattercarpet"}],"scattergeo":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scattergeo"}],"scattergl":[{"marker":{"line":{"color":"#283442"}},"type":"scattergl"}],"scattermapbox":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scattermapbox"}],"scatterpolar":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scatterpolar"}],"scatterpolargl":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scatterpolargl"}],"scatterternary":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scatterternary"}],"surface":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"surface"}],"table":[{"cells":{"fill":{"color":"#506784"},"line":{"color":"rgb(17,17,17)"}},"header":{"fill":{"color":"#2a3f5f"},"line":{"color":"rgb(17,17,17)"}},"type":"table"}]},"layout":{"annotationdefaults":{"arrowcolor":"#f2f5fa","arrowhead":0,"arrowwidth":1},"autotypenumbers":"strict","coloraxis":{"colorbar":{"outlinewidth":0,"ticks":""}},"colorscale":{"diverging":[[0,"#8e0152"],[0.1,"#c51b7d"],[0.2,"#de77ae"],[0.3,"#f1b6da"],[0.4,"#fde0ef"],[0.5,"#f7f7f7"],[0.6,"#e6f5d0"],[0.7,"#b8e186"],[0.8,"#7fbc41"],[0.9,"#4d9221"],[1,"#276419"]],"sequential":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"sequentialminus":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]]},"colorway":["#636efa","#EF553B","#00cc96","#ab63fa","#FFA15A","#19d3f3","#FF6692","#B6E880","#FF97FF","#FECB52"],"font":{"color":"#f2f5fa"},"geo":{"bgcolor":"rgb(17,17,17)","lakecolor":"rgb(17,17,17)","landcolor":"rgb(17,17,17)","showlakes":true,"showland":true,"subunitcolor":"#506784"},"hoverlabel":{"align":"left"},"hovermode":"closest","mapbox":{"style":"dark"},"paper_bgcolor":"rgb(17,17,17)","plot_bgcolor":"rgb(17,17,17)","polar":{"angularaxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""},"bgcolor":"rgb(17,17,17)","radialaxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""}},"scene":{"xaxis":{"backgroundcolor":"rgb(17,17,17)","gridcolor":"#506784","gridwidth":2,"linecolor":"#506784","showbackground":true,"ticks":"","zerolinecolor":"#C8D4E3"},"yaxis":{"backgroundcolor":"rgb(17,17,17)","gridcolor":"#506784","gridwidth":2,"linecolor":"#506784","showbackground":true,"ticks":"","zerolinecolor":"#C8D4E3"},"zaxis":{"backgroundcolor":"rgb(17,17,17)","gridcolor":"#506784","gridwidth":2,"linecolor":"#506784","showbackground":true,"ticks":"","zerolinecolor":"#C8D4E3"}},"shapedefaults":{"line":{"color":"#f2f5fa"}},"sliderdefaults":{"bgcolor":"#C8D4E3","bordercolor":"rgb(17,17,17)","borderwidth":1,"tickwidth":0},"ternary":{"aaxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""},"baxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""},"bgcolor":"rgb(17,17,17)","caxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""}},"title":{"x":0.05},"updatemenudefaults":{"bgcolor":"#506784","borderwidth":0},"xaxis":{"automargin":true,"gridcolor":"#283442","linecolor":"#506784","ticks":"","title":{"standoff":15},"zerolinecolor":"#283442","zerolinewidth":2},"yaxis":{"automargin":true,"gridcolor":"#283442","linecolor":"#506784","ticks":"","title":{"standoff":15},"zerolinecolor":"#283442","zerolinewidth":2}}},"title":{"text":"Correctness of oversampled ratio Sequential Testing Design","x":0.5},"yaxis":{"title":{"text":"False Positive Rate"}}}});
</script>
<p>This chart above is just to assure you, that for conversions over-sampled <code>GST</code> doesn&rsquo;t work neither, I can&rsquo;t help but prove that <code>GST</code> in oversampling design is a flaw, while yet much better than Statsig v1 Alpha Corrections.</p>
<h4 id="true-positives-1">True Positives<a hidden class="anchor" aria-hidden="true" href="#true-positives-1">#</a></h4>
<p>Let&rsquo;s take a brief look at the power comparison for a couple different effect sizes</p>
<details>
<summary>Code</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>df <span style="color:#f92672">=</span> monte_carlo(aa_test<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>, metric<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;choice&#34;</span>, effect_size<span style="color:#f92672">=</span><span style="color:#ae81ff">0.10</span>)
</span></span><span style="display:flex;"><span>df
</span></span></code></pre></div></details>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
<p></style></p>
<table>
<thead>
<tr>
<th></th>
<th>PositiveRate</th>
<th>SampleSize</th>
</tr>
</thead>
<tbody>
<tr>
<td>No_Seq</td>
<td>0.480</td>
<td>4500</td>
</tr>
<tr>
<td>GAVI</td>
<td>0.240</td>
<td>2482</td>
</tr>
<tr>
<td>mSPRT</td>
<td>0.310</td>
<td>1441</td>
</tr>
<tr>
<td>StatSig_SPRT</td>
<td>0.226</td>
<td>1702</td>
</tr>
<tr>
<td>GST_linear</td>
<td>0.420</td>
<td>2700</td>
</tr>
<tr>
<td>GST_quadratic</td>
<td>0.449</td>
<td>3150</td>
</tr>
<tr>
<td>GST_cubic</td>
<td>0.460</td>
<td>3600</td>
</tr>
</tbody>
</table>
</div>
<details>
<summary>Code</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>plot_positive_rate(df, aa_test<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>, sampling<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;ratio&#34;</span>)
</span></span></code></pre></div></details>


<div id="plotly-008"></div>

<script>
  Plotly.newPlot(document.getElementById("plotly-008"), {"data":[{"error_y":{"array":[0.005,0.004,0.004,0.004,0.005,0.005,0.005],"type":"data"},"marker":{"color":"rgba(254, 203, 82, 0.5)"},"type":"bar","x":["No_Seq","GAVI","mSPRT","StatSig_SPRT","GST_linear","GST_quadratic","GST_cubic"],"y":[0.48,0.241,0.311,0.225,0.421,0.451,0.462]}],"layout":{"hovermode":"x","template":{"data":{"bar":[{"error_x":{"color":"#f2f5fa"},"error_y":{"color":"#f2f5fa"},"marker":{"line":{"color":"rgb(17,17,17)","width":0.5},"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"bar"}],"barpolar":[{"marker":{"line":{"color":"rgb(17,17,17)","width":0.5},"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"barpolar"}],"carpet":[{"aaxis":{"endlinecolor":"#A2B1C6","gridcolor":"#506784","linecolor":"#506784","minorgridcolor":"#506784","startlinecolor":"#A2B1C6"},"baxis":{"endlinecolor":"#A2B1C6","gridcolor":"#506784","linecolor":"#506784","minorgridcolor":"#506784","startlinecolor":"#A2B1C6"},"type":"carpet"}],"choropleth":[{"colorbar":{"outlinewidth":0,"ticks":""},"type":"choropleth"}],"contour":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"contour"}],"contourcarpet":[{"colorbar":{"outlinewidth":0,"ticks":""},"type":"contourcarpet"}],"heatmap":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"heatmap"}],"heatmapgl":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"heatmapgl"}],"histogram":[{"marker":{"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"histogram"}],"histogram2d":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"histogram2d"}],"histogram2dcontour":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"histogram2dcontour"}],"mesh3d":[{"colorbar":{"outlinewidth":0,"ticks":""},"type":"mesh3d"}],"parcoords":[{"line":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"parcoords"}],"pie":[{"automargin":true,"type":"pie"}],"scatter":[{"marker":{"line":{"color":"#283442"}},"type":"scatter"}],"scatter3d":[{"line":{"colorbar":{"outlinewidth":0,"ticks":""}},"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scatter3d"}],"scattercarpet":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scattercarpet"}],"scattergeo":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scattergeo"}],"scattergl":[{"marker":{"line":{"color":"#283442"}},"type":"scattergl"}],"scattermapbox":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scattermapbox"}],"scatterpolar":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scatterpolar"}],"scatterpolargl":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scatterpolargl"}],"scatterternary":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scatterternary"}],"surface":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"surface"}],"table":[{"cells":{"fill":{"color":"#506784"},"line":{"color":"rgb(17,17,17)"}},"header":{"fill":{"color":"#2a3f5f"},"line":{"color":"rgb(17,17,17)"}},"type":"table"}]},"layout":{"annotationdefaults":{"arrowcolor":"#f2f5fa","arrowhead":0,"arrowwidth":1},"autotypenumbers":"strict","coloraxis":{"colorbar":{"outlinewidth":0,"ticks":""}},"colorscale":{"diverging":[[0,"#8e0152"],[0.1,"#c51b7d"],[0.2,"#de77ae"],[0.3,"#f1b6da"],[0.4,"#fde0ef"],[0.5,"#f7f7f7"],[0.6,"#e6f5d0"],[0.7,"#b8e186"],[0.8,"#7fbc41"],[0.9,"#4d9221"],[1,"#276419"]],"sequential":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"sequentialminus":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]]},"colorway":["#636efa","#EF553B","#00cc96","#ab63fa","#FFA15A","#19d3f3","#FF6692","#B6E880","#FF97FF","#FECB52"],"font":{"color":"#f2f5fa"},"geo":{"bgcolor":"rgb(17,17,17)","lakecolor":"rgb(17,17,17)","landcolor":"rgb(17,17,17)","showlakes":true,"showland":true,"subunitcolor":"#506784"},"hoverlabel":{"align":"left"},"hovermode":"closest","mapbox":{"style":"dark"},"paper_bgcolor":"rgb(17,17,17)","plot_bgcolor":"rgb(17,17,17)","polar":{"angularaxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""},"bgcolor":"rgb(17,17,17)","radialaxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""}},"scene":{"xaxis":{"backgroundcolor":"rgb(17,17,17)","gridcolor":"#506784","gridwidth":2,"linecolor":"#506784","showbackground":true,"ticks":"","zerolinecolor":"#C8D4E3"},"yaxis":{"backgroundcolor":"rgb(17,17,17)","gridcolor":"#506784","gridwidth":2,"linecolor":"#506784","showbackground":true,"ticks":"","zerolinecolor":"#C8D4E3"},"zaxis":{"backgroundcolor":"rgb(17,17,17)","gridcolor":"#506784","gridwidth":2,"linecolor":"#506784","showbackground":true,"ticks":"","zerolinecolor":"#C8D4E3"}},"shapedefaults":{"line":{"color":"#f2f5fa"}},"sliderdefaults":{"bgcolor":"#C8D4E3","bordercolor":"rgb(17,17,17)","borderwidth":1,"tickwidth":0},"ternary":{"aaxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""},"baxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""},"bgcolor":"rgb(17,17,17)","caxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""}},"title":{"x":0.05},"updatemenudefaults":{"bgcolor":"#506784","borderwidth":0},"xaxis":{"automargin":true,"gridcolor":"#283442","linecolor":"#506784","ticks":"","title":{"standoff":15},"zerolinecolor":"#283442","zerolinewidth":2},"yaxis":{"automargin":true,"gridcolor":"#283442","linecolor":"#506784","ticks":"","title":{"standoff":15},"zerolinecolor":"#283442","zerolinewidth":2}}},"title":{"text":"Power of ratio Sequential Testing Design","x":0.5},"yaxis":{"title":{"text":"True Positive Rate"}}}});
</script>
<details>
<summary>Code</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>df <span style="color:#f92672">=</span> monte_carlo(aa_test<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>, metric<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;choice&#34;</span>, effect_size<span style="color:#f92672">=</span><span style="color:#ae81ff">0.2</span>)
</span></span><span style="display:flex;"><span>df
</span></span></code></pre></div></details>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
<p></style></p>
<table>
<thead>
<tr>
<th></th>
<th>PositiveRate</th>
<th>SampleSize</th>
</tr>
</thead>
<tbody>
<tr>
<td>No_Seq</td>
<td>0.930</td>
<td>4500</td>
</tr>
<tr>
<td>GAVI</td>
<td>0.767</td>
<td>2127</td>
</tr>
<tr>
<td>mSPRT</td>
<td>0.796</td>
<td>1593</td>
</tr>
<tr>
<td>StatSig_SPRT</td>
<td>0.718</td>
<td>1923</td>
</tr>
<tr>
<td>GST_linear</td>
<td>0.898</td>
<td>2250</td>
</tr>
<tr>
<td>GST_quadratic</td>
<td>0.915</td>
<td>2250</td>
</tr>
<tr>
<td>GST_cubic</td>
<td>0.921</td>
<td>2700</td>
</tr>
</tbody>
</table>
</div>
<details>
<summary>Code</summary>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>plot_positive_rate(df, aa_test<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>, sampling<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;strong effect&#34;</span>)
</span></span></code></pre></div></details>


<div id="plotly-009"></div>

<script>
  Plotly.newPlot(document.getElementById("plotly-009"), {"data":[{"error_y":{"array":[0.002,0.004,0.004,0.004,0.003,0.003,0.003],"type":"data"},"marker":{"color":"rgba(99, 110, 250, 0.5)"},"type":"bar","x":["No_Seq","GAVI","mSPRT","StatSig_SPRT","GST_linear","GST_quadratic","GST_cubic"],"y":[0.928,0.766,0.794,0.716,0.894,0.912,0.918]}],"layout":{"hovermode":"x","template":{"data":{"bar":[{"error_x":{"color":"#f2f5fa"},"error_y":{"color":"#f2f5fa"},"marker":{"line":{"color":"rgb(17,17,17)","width":0.5},"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"bar"}],"barpolar":[{"marker":{"line":{"color":"rgb(17,17,17)","width":0.5},"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"barpolar"}],"carpet":[{"aaxis":{"endlinecolor":"#A2B1C6","gridcolor":"#506784","linecolor":"#506784","minorgridcolor":"#506784","startlinecolor":"#A2B1C6"},"baxis":{"endlinecolor":"#A2B1C6","gridcolor":"#506784","linecolor":"#506784","minorgridcolor":"#506784","startlinecolor":"#A2B1C6"},"type":"carpet"}],"choropleth":[{"colorbar":{"outlinewidth":0,"ticks":""},"type":"choropleth"}],"contour":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"contour"}],"contourcarpet":[{"colorbar":{"outlinewidth":0,"ticks":""},"type":"contourcarpet"}],"heatmap":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"heatmap"}],"heatmapgl":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"heatmapgl"}],"histogram":[{"marker":{"pattern":{"fillmode":"overlay","size":10,"solidity":0.2}},"type":"histogram"}],"histogram2d":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"histogram2d"}],"histogram2dcontour":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"histogram2dcontour"}],"mesh3d":[{"colorbar":{"outlinewidth":0,"ticks":""},"type":"mesh3d"}],"parcoords":[{"line":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"parcoords"}],"pie":[{"automargin":true,"type":"pie"}],"scatter":[{"marker":{"line":{"color":"#283442"}},"type":"scatter"}],"scatter3d":[{"line":{"colorbar":{"outlinewidth":0,"ticks":""}},"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scatter3d"}],"scattercarpet":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scattercarpet"}],"scattergeo":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scattergeo"}],"scattergl":[{"marker":{"line":{"color":"#283442"}},"type":"scattergl"}],"scattermapbox":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scattermapbox"}],"scatterpolar":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scatterpolar"}],"scatterpolargl":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scatterpolargl"}],"scatterternary":[{"marker":{"colorbar":{"outlinewidth":0,"ticks":""}},"type":"scatterternary"}],"surface":[{"colorbar":{"outlinewidth":0,"ticks":""},"colorscale":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"type":"surface"}],"table":[{"cells":{"fill":{"color":"#506784"},"line":{"color":"rgb(17,17,17)"}},"header":{"fill":{"color":"#2a3f5f"},"line":{"color":"rgb(17,17,17)"}},"type":"table"}]},"layout":{"annotationdefaults":{"arrowcolor":"#f2f5fa","arrowhead":0,"arrowwidth":1},"autotypenumbers":"strict","coloraxis":{"colorbar":{"outlinewidth":0,"ticks":""}},"colorscale":{"diverging":[[0,"#8e0152"],[0.1,"#c51b7d"],[0.2,"#de77ae"],[0.3,"#f1b6da"],[0.4,"#fde0ef"],[0.5,"#f7f7f7"],[0.6,"#e6f5d0"],[0.7,"#b8e186"],[0.8,"#7fbc41"],[0.9,"#4d9221"],[1,"#276419"]],"sequential":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]],"sequentialminus":[[0,"#0d0887"],[0.1111111111111111,"#46039f"],[0.2222222222222222,"#7201a8"],[0.3333333333333333,"#9c179e"],[0.4444444444444444,"#bd3786"],[0.5555555555555556,"#d8576b"],[0.6666666666666666,"#ed7953"],[0.7777777777777778,"#fb9f3a"],[0.8888888888888888,"#fdca26"],[1,"#f0f921"]]},"colorway":["#636efa","#EF553B","#00cc96","#ab63fa","#FFA15A","#19d3f3","#FF6692","#B6E880","#FF97FF","#FECB52"],"font":{"color":"#f2f5fa"},"geo":{"bgcolor":"rgb(17,17,17)","lakecolor":"rgb(17,17,17)","landcolor":"rgb(17,17,17)","showlakes":true,"showland":true,"subunitcolor":"#506784"},"hoverlabel":{"align":"left"},"hovermode":"closest","mapbox":{"style":"dark"},"paper_bgcolor":"rgb(17,17,17)","plot_bgcolor":"rgb(17,17,17)","polar":{"angularaxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""},"bgcolor":"rgb(17,17,17)","radialaxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""}},"scene":{"xaxis":{"backgroundcolor":"rgb(17,17,17)","gridcolor":"#506784","gridwidth":2,"linecolor":"#506784","showbackground":true,"ticks":"","zerolinecolor":"#C8D4E3"},"yaxis":{"backgroundcolor":"rgb(17,17,17)","gridcolor":"#506784","gridwidth":2,"linecolor":"#506784","showbackground":true,"ticks":"","zerolinecolor":"#C8D4E3"},"zaxis":{"backgroundcolor":"rgb(17,17,17)","gridcolor":"#506784","gridwidth":2,"linecolor":"#506784","showbackground":true,"ticks":"","zerolinecolor":"#C8D4E3"}},"shapedefaults":{"line":{"color":"#f2f5fa"}},"sliderdefaults":{"bgcolor":"#C8D4E3","bordercolor":"rgb(17,17,17)","borderwidth":1,"tickwidth":0},"ternary":{"aaxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""},"baxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""},"bgcolor":"rgb(17,17,17)","caxis":{"gridcolor":"#506784","linecolor":"#506784","ticks":""}},"title":{"x":0.05},"updatemenudefaults":{"bgcolor":"#506784","borderwidth":0},"xaxis":{"automargin":true,"gridcolor":"#283442","linecolor":"#506784","ticks":"","title":{"standoff":15},"zerolinecolor":"#283442","zerolinewidth":2},"yaxis":{"automargin":true,"gridcolor":"#283442","linecolor":"#506784","ticks":"","title":{"standoff":15},"zerolinecolor":"#283442","zerolinewidth":2}}},"title":{"text":"Power of strong effect Sequential Testing Design","x":0.5},"yaxis":{"title":{"text":"True Positive Rate"}}}});
</script>
<p>With the growing effect size the relative difference in power is getting lower, but you can check that with any kind of reasonable effect size, <code>GST</code> outperforms <code>AVI</code> and what is more even for conversion variable, where <code>mSPRT</code> method doesn&rsquo;t really control Type I error rate, it&rsquo;s less powerful than <code>GST</code> after all.</p>
<h1 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h1>
<p>Generally speaking, I&rsquo;d rather say that <code>GST</code> is yet the best framework for sequential testing, despite all the recent publications on cutting-edge <code>AVI</code> variations.</p>
<p>However, I have to make a clause: while <code>AVI</code> is noticeably less powerful, it&rsquo;s perfect to work in a streaming manner for guardrail metrics, while GST is better for target metrics within you AB test.</p>
<blockquote>
<p><strong>üí° Practical Tip</strong></p>
<p>Combining these methodologies you may set up robust Sequential Testing framework, gaining from both: quick detection of major deterioration in your product with <code>AVI</code> and reliable uplifts discoveries in your decisive metrics with the most powerful <code>GST</code> procedure.</p>
</blockquote>
<p>Another important point is to be conscious about the choice of the specific version of the algorithms that you will use.</p>
<p>For instance running an under-sampled experiments where <code>GST</code> with strict alpha spending functions, like Cubic, applied is less preferable, under-sampling works better with permissive spending functions, as well as over-sampling with Cubic spending is worse as it inflates $\alpha$ more.</p>
<blockquote>
<p><strong>üí° General Rule</strong></p>
<p>The more permissive spending function is the faster effect is identified, but the less power at the end of experiment is achieved, what is especially striking for less substantial effect sizes.</p>
</blockquote>
<p>Rounding this extensive blog-post up, here are the recommendations on choosing the sequential testing framework wrapped up into a single decision tree:</p>
<!-- draw.io diagram -->
<div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;lightbox&quot;:false,&quot;nav&quot;:true,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile host=\&quot;ac.draw.io\&quot; agent=\&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36\&quot; version=\&quot;25.0.3\&quot;&gt;\n  &lt;diagram name=\&quot;Page-1\&quot; id=\&quot;10a91c8b-09ff-31b1-d368-03940ed4cc9e\&quot;&gt;\n    &lt;mxGraphModel dx=\&quot;1985\&quot; dy=\&quot;1050\&quot; grid=\&quot;1\&quot; gridSize=\&quot;10\&quot; guides=\&quot;1\&quot; tooltips=\&quot;1\&quot; connect=\&quot;1\&quot; arrows=\&quot;1\&quot; fold=\&quot;1\&quot; page=\&quot;1\&quot; pageScale=\&quot;1\&quot; pageWidth=\&quot;1100\&quot; pageHeight=\&quot;850\&quot; background=\&quot;none\&quot; math=\&quot;0\&quot; shadow=\&quot;0\&quot;&gt;\n      &lt;root&gt;\n        &lt;mxCell id=\&quot;0\&quot; /&gt;\n        &lt;mxCell id=\&quot;1\&quot; parent=\&quot;0\&quot; /&gt;\n        &lt;mxCell id=\&quot;BCZGtb4ARAkY1Pyahnf2-1\&quot; value=\&quot;\&quot; style=\&quot;rounded=1;whiteSpace=wrap;html=1;strokeColor=#9B9C9D;glass=0;shadow=0;fillColor=#9B9C9D;\&quot; vertex=\&quot;1\&quot; parent=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;60\&quot; y=\&quot;10\&quot; width=\&quot;950\&quot; height=\&quot;830\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;62893188c0fa7362-1\&quot; value=\&quot;Data is supplied in a streaming manner\&quot; style=\&quot;whiteSpace=wrap;html=1;rounded=1;shadow=1;labelBackgroundColor=none;strokeWidth=1;fontFamily=Verdana;fontSize=12;align=center;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;590\&quot; y=\&quot;30\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;62893188c0fa7362-2\&quot; value=\&quot;Sample size unknown\&quot; style=\&quot;whiteSpace=wrap;html=1;rounded=1;shadow=1;labelBackgroundColor=none;strokeWidth=1;fontFamily=Verdana;fontSize=12;align=center;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;350\&quot; y=\&quot;140\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;62893188c0fa7362-5\&quot; value=\&quot;No\&quot; style=\&quot;rounded=0;html=1;labelBackgroundColor=none;startArrow=none;startFill=0;startSize=5;endArrow=classic;endFill=1;endSize=5;jettySize=auto;orthogonalLoop=1;strokeWidth=1;fontFamily=Verdana;fontSize=12;exitX=0.108;exitY=1;exitDx=0;exitDy=0;exitPerimeter=0;\&quot; parent=\&quot;1\&quot; source=\&quot;62893188c0fa7362-1\&quot; target=\&quot;62893188c0fa7362-2\&quot; edge=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-0.2051\&quot; y=\&quot;-17\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;&gt;\n            &lt;mxPoint as=\&quot;offset\&quot; /&gt;\n          &lt;/mxGeometry&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;62893188c0fa7362-8\&quot; value=\&quot;Only upper bound for observations number is known\&quot; style=\&quot;whiteSpace=wrap;html=1;rounded=1;shadow=1;labelBackgroundColor=none;strokeWidth=1;fontFamily=Verdana;fontSize=12;align=center;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;110\&quot; y=\&quot;410\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;62893188c0fa7362-9\&quot; value=\&quot;There are many intermittent analyses (&amp;amp;gt;30)&amp;amp;nbsp;\&quot; style=\&quot;whiteSpace=wrap;html=1;rounded=1;shadow=1;labelBackgroundColor=none;strokeWidth=1;fontFamily=Verdana;fontSize=12;align=center;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;590\&quot; y=\&quot;250\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;62893188c0fa7362-10\&quot; value=\&quot;&amp;lt;span&amp;gt;Always Valid Inference (AVI)&amp;lt;/span&amp;gt;\&quot; style=\&quot;whiteSpace=wrap;html=1;rounded=0;shadow=1;labelBackgroundColor=none;strokeWidth=2;fontFamily=Verdana;fontSize=12;align=center;fillColor=#dae8fc;strokeColor=#6c8ebf;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;850\&quot; y=\&quot;140\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;62893188c0fa7362-13\&quot; value=\&quot;Large-scale effect is expected from the experiment\&quot; style=\&quot;whiteSpace=wrap;html=1;rounded=1;shadow=1;labelBackgroundColor=none;strokeWidth=1;fontFamily=Verdana;fontSize=12;align=center;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;110\&quot; y=\&quot;570\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;62893188c0fa7362-14\&quot; value=\&quot;No\&quot; style=\&quot;rounded=0;html=1;labelBackgroundColor=none;startArrow=none;startFill=0;startSize=5;endArrow=classic;endFill=1;endSize=5;jettySize=auto;orthogonalLoop=1;strokeWidth=1;fontFamily=Verdana;fontSize=12;exitX=0.5;exitY=1;exitDx=0;exitDy=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;\&quot; parent=\&quot;1\&quot; source=\&quot;eBBfYNGfGk0e3oGPA11c-2\&quot; target=\&quot;62893188c0fa7362-8\&quot; edge=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;0.1111\&quot; y=\&quot;-20\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;&gt;\n            &lt;mxPoint as=\&quot;offset\&quot; /&gt;\n          &lt;/mxGeometry&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;62893188c0fa7362-15\&quot; value=\&quot;Yes\&quot; style=\&quot;rounded=0;html=1;labelBackgroundColor=none;startArrow=none;startFill=0;startSize=5;endArrow=classic;endFill=1;endSize=5;jettySize=auto;orthogonalLoop=1;strokeWidth=1;fontFamily=Verdana;fontSize=12;exitX=1;exitY=1;exitDx=0;exitDy=0;entryX=0;entryY=0;entryDx=0;entryDy=0;\&quot; parent=\&quot;1\&quot; source=\&quot;62893188c0fa7362-2\&quot; target=\&quot;62893188c0fa7362-9\&quot; edge=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-0.2\&quot; y=\&quot;14\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;&gt;\n            &lt;mxPoint as=\&quot;offset\&quot; /&gt;\n          &lt;/mxGeometry&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;62893188c0fa7362-16\&quot; value=\&quot;Yes\&quot; style=\&quot;rounded=0;html=1;labelBackgroundColor=none;startArrow=none;startFill=0;endArrow=classic;endFill=1;jettySize=auto;orthogonalLoop=1;strokeWidth=1;fontFamily=Verdana;fontSize=12;exitX=0.933;exitY=1.017;exitDx=0;exitDy=0;exitPerimeter=0;strokeColor=default;entryX=0;entryY=0;entryDx=0;entryDy=0;\&quot; parent=\&quot;1\&quot; source=\&quot;62893188c0fa7362-1\&quot; target=\&quot;62893188c0fa7362-10\&quot; edge=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-0.0325\&quot; y=\&quot;11\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;&gt;\n            &lt;mxPoint x=\&quot;1\&quot; as=\&quot;offset\&quot; /&gt;\n            &lt;mxPoint x=\&quot;810\&quot; y=\&quot;220\&quot; as=\&quot;sourcePoint\&quot; /&gt;\n            &lt;mxPoint x=\&quot;880\&quot; y=\&quot;110\&quot; as=\&quot;targetPoint\&quot; /&gt;\n          &lt;/mxGeometry&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;62893188c0fa7362-19\&quot; value=\&quot;No\&quot; style=\&quot;rounded=0;html=1;labelBackgroundColor=none;startArrow=none;startFill=0;startSize=5;endArrow=classic;endFill=1;endSize=5;jettySize=auto;orthogonalLoop=1;strokeWidth=1;fontFamily=Verdana;fontSize=12;exitX=0.5;exitY=1;exitDx=0;exitDy=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;\&quot; parent=\&quot;1\&quot; source=\&quot;62893188c0fa7362-8\&quot; target=\&quot;62893188c0fa7362-13\&quot; edge=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-0.2857\&quot; y=\&quot;-20\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;&gt;\n            &lt;mxPoint as=\&quot;offset\&quot; /&gt;\n            &lt;mxPoint x=\&quot;190\&quot; y=\&quot;570\&quot; as=\&quot;targetPoint\&quot; /&gt;\n          &lt;/mxGeometry&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;62893188c0fa7362-21\&quot; value=\&quot;&amp;lt;span&amp;gt;Classic GST with permissive alpha spending function&amp;lt;/span&amp;gt;\&quot; style=\&quot;whiteSpace=wrap;html=1;rounded=0;shadow=1;labelBackgroundColor=none;strokeWidth=2;fontFamily=Verdana;fontSize=12;align=center;fillColor=#d5e8d4;strokeColor=#82b366;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;390\&quot; y=\&quot;490\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;62893188c0fa7362-22\&quot; value=\&quot;Classic GST&amp;lt;br&amp;gt;with strict alpha spending function\&quot; style=\&quot;whiteSpace=wrap;html=1;rounded=0;shadow=1;labelBackgroundColor=none;strokeWidth=2;fontFamily=Verdana;fontSize=12;align=center;fillColor=#d5e8d4;strokeColor=#82b366;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;110\&quot; y=\&quot;730\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;62893188c0fa7362-25\&quot; value=\&quot;Yes\&quot; style=\&quot;rounded=0;html=1;labelBackgroundColor=none;startArrow=none;startFill=0;startSize=5;endArrow=classic;endFill=1;endSize=5;jettySize=auto;orthogonalLoop=1;strokeWidth=1;fontFamily=Verdana;fontSize=12;exitX=1;exitY=0.5;exitDx=0;exitDy=0;entryX=0;entryY=0;entryDx=0;entryDy=0;\&quot; parent=\&quot;1\&quot; source=\&quot;62893188c0fa7362-8\&quot; target=\&quot;62893188c0fa7362-21\&quot; edge=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;0.1373\&quot; y=\&quot;16\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;&gt;\n            &lt;mxPoint as=\&quot;offset\&quot; /&gt;\n            &lt;mxPoint x=\&quot;245.71428571428578\&quot; y=\&quot;605\&quot; as=\&quot;sourcePoint\&quot; /&gt;\n          &lt;/mxGeometry&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;62893188c0fa7362-26\&quot; value=\&quot;No\&quot; style=\&quot;rounded=0;html=1;labelBackgroundColor=none;startArrow=none;startFill=0;startSize=5;endArrow=classic;endFill=1;endSize=5;jettySize=auto;orthogonalLoop=1;strokeWidth=1;fontFamily=Verdana;fontSize=12;exitX=0.5;exitY=1;exitDx=0;exitDy=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;\&quot; parent=\&quot;1\&quot; source=\&quot;62893188c0fa7362-13\&quot; target=\&quot;62893188c0fa7362-22\&quot; edge=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;0.0033\&quot; y=\&quot;-12\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;&gt;\n            &lt;mxPoint as=\&quot;offset\&quot; /&gt;\n          &lt;/mxGeometry&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;62893188c0fa7362-27\&quot; value=\&quot;Yes\&quot; style=\&quot;rounded=0;html=1;labelBackgroundColor=none;startArrow=none;startFill=0;startSize=5;endArrow=classic;endFill=1;endSize=5;jettySize=auto;orthogonalLoop=1;strokeWidth=1;fontFamily=Verdana;fontSize=12;entryX=0;entryY=1;entryDx=0;entryDy=0;exitX=1;exitY=0.5;exitDx=0;exitDy=0;\&quot; parent=\&quot;1\&quot; source=\&quot;62893188c0fa7362-13\&quot; target=\&quot;62893188c0fa7362-21\&quot; edge=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;0.1373\&quot; y=\&quot;16\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;&gt;\n            &lt;mxPoint as=\&quot;offset\&quot; /&gt;\n            &lt;mxPoint x=\&quot;250\&quot; y=\&quot;600\&quot; as=\&quot;sourcePoint\&quot; /&gt;\n          &lt;/mxGeometry&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;f_bxW6br7S2beZE4IyPl-2\&quot; value=\&quot;Yes\&quot; style=\&quot;rounded=0;html=1;labelBackgroundColor=none;startArrow=none;startFill=0;startSize=5;endArrow=classic;endFill=1;endSize=5;jettySize=auto;orthogonalLoop=1;strokeWidth=1;fontFamily=Verdana;fontSize=12;entryX=0;entryY=1;entryDx=0;entryDy=0;exitX=1.025;exitY=0.133;exitDx=0;exitDy=0;exitPerimeter=0;\&quot; parent=\&quot;1\&quot; source=\&quot;62893188c0fa7362-9\&quot; target=\&quot;62893188c0fa7362-10\&quot; edge=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-0.0325\&quot; y=\&quot;11\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;&gt;\n            &lt;mxPoint x=\&quot;1\&quot; as=\&quot;offset\&quot; /&gt;\n            &lt;mxPoint x=\&quot;710\&quot; y=\&quot;270\&quot; as=\&quot;sourcePoint\&quot; /&gt;\n            &lt;mxPoint x=\&quot;780\&quot; y=\&quot;300\&quot; as=\&quot;targetPoint\&quot; /&gt;\n          &lt;/mxGeometry&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;f_bxW6br7S2beZE4IyPl-4\&quot; value=\&quot;&amp;lt;span&amp;gt;Simple Bonferroni Correction&amp;lt;/span&amp;gt;\&quot; style=\&quot;whiteSpace=wrap;html=1;rounded=0;shadow=1;labelBackgroundColor=none;strokeWidth=2;fontFamily=Verdana;fontSize=12;align=center;fillColor=#e1d5e7;strokeColor=#9673a6;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;850\&quot; y=\&quot;360\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;f_bxW6br7S2beZE4IyPl-5\&quot; value=\&quot;No\&quot; style=\&quot;rounded=0;html=1;labelBackgroundColor=none;startArrow=none;startFill=0;startSize=5;endArrow=classic;endFill=1;endSize=5;jettySize=auto;orthogonalLoop=1;strokeWidth=1;fontFamily=Verdana;fontSize=12;exitX=1;exitY=1;exitDx=0;exitDy=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;\&quot; parent=\&quot;1\&quot; source=\&quot;62893188c0fa7362-9\&quot; target=\&quot;f_bxW6br7S2beZE4IyPl-4\&quot; edge=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-0.2\&quot; y=\&quot;-14\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;&gt;\n            &lt;mxPoint as=\&quot;offset\&quot; /&gt;\n            &lt;mxPoint x=\&quot;740\&quot; y=\&quot;400\&quot; as=\&quot;sourcePoint\&quot; /&gt;\n            &lt;mxPoint x=\&quot;670\&quot; y=\&quot;470\&quot; as=\&quot;targetPoint\&quot; /&gt;\n          &lt;/mxGeometry&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;eBBfYNGfGk0e3oGPA11c-2\&quot; value=\&quot;Is there a need to run a test for an arbitrary long time\&quot; style=\&quot;whiteSpace=wrap;html=1;rounded=1;shadow=1;labelBackgroundColor=none;strokeWidth=1;fontFamily=Verdana;fontSize=12;align=center;\&quot; parent=\&quot;1\&quot; vertex=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;110\&quot; y=\&quot;250\&quot; width=\&quot;120\&quot; height=\&quot;60\&quot; as=\&quot;geometry\&quot; /&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;eBBfYNGfGk0e3oGPA11c-3\&quot; value=\&quot;No\&quot; style=\&quot;rounded=0;html=1;labelBackgroundColor=none;startArrow=none;startFill=0;startSize=5;endArrow=classic;endFill=1;endSize=5;jettySize=auto;orthogonalLoop=1;strokeWidth=1;fontFamily=Verdana;fontSize=12;exitX=0;exitY=1;exitDx=0;exitDy=0;entryX=1;entryY=0;entryDx=0;entryDy=0;\&quot; parent=\&quot;1\&quot; source=\&quot;62893188c0fa7362-2\&quot; target=\&quot;eBBfYNGfGk0e3oGPA11c-2\&quot; edge=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-0.2\&quot; y=\&quot;-14\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;&gt;\n            &lt;mxPoint as=\&quot;offset\&quot; /&gt;\n            &lt;mxPoint x=\&quot;470\&quot; y=\&quot;245\&quot; as=\&quot;sourcePoint\&quot; /&gt;\n            &lt;mxPoint x=\&quot;340\&quot; y=\&quot;460\&quot; as=\&quot;targetPoint\&quot; /&gt;\n          &lt;/mxGeometry&gt;\n        &lt;/mxCell&gt;\n        &lt;mxCell id=\&quot;eBBfYNGfGk0e3oGPA11c-4\&quot; value=\&quot;Yes\&quot; style=\&quot;rounded=0;html=1;labelBackgroundColor=none;startArrow=none;startFill=0;startSize=5;endArrow=classic;endFill=1;endSize=5;jettySize=auto;orthogonalLoop=1;strokeWidth=1;fontFamily=Verdana;fontSize=12;exitX=1;exitY=0.5;exitDx=0;exitDy=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;\&quot; parent=\&quot;1\&quot; source=\&quot;eBBfYNGfGk0e3oGPA11c-2\&quot; target=\&quot;62893188c0fa7362-9\&quot; edge=\&quot;1\&quot;&gt;\n          &lt;mxGeometry x=\&quot;-0.027\&quot; y=\&quot;20\&quot; relative=\&quot;1\&quot; as=\&quot;geometry\&quot;&gt;\n            &lt;mxPoint as=\&quot;offset\&quot; /&gt;\n            &lt;mxPoint x=\&quot;480\&quot; y=\&quot;210\&quot; as=\&quot;sourcePoint\&quot; /&gt;\n            &lt;mxPoint x=\&quot;600\&quot; y=\&quot;275\&quot; as=\&quot;targetPoint\&quot; /&gt;\n          &lt;/mxGeometry&gt;\n        &lt;/mxCell&gt;\n      &lt;/root&gt;\n    &lt;/mxGraphModel&gt;\n  &lt;/diagram&gt;\n&lt;/mxfile&gt;\n&quot;}"></div>
<script type="text/javascript" src="https://viewer.diagrams.net/js/viewer-static.min.js"></script>
<h1 id="references">References<a hidden class="anchor" aria-hidden="true" href="#references">#</a></h1>
<p><a href="https://github.com/NPodlozhniy/seqabpy"><code>seqabpy</code></a> is an open source library that is perfect for <code>GST</code> and <code>AVI</code> in Python. In addition to implemented functionality it contains all the referenced original papers in functions&rsquo; docstrings, so you may get acquainted with the original works.</p>
<p>There were similar posts made by Booking and Spotify, however they do not share implementation details, hence you may read it to deepen the understanding, but barely can apply it in practice:</p>
<ul>
<li><a href="https://engineering.atspotify.com/2023/03/choosing-sequential-testing-framework-comparisons-and-discussions/">Choosing a Sequential Testing Framework by Spotify</a></li>
<li><a href="https://booking.ai/sequential-testing-at-booking-com-650954a569c7">Sequential Testing at Booking</a></li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>

<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share Sequential Testing Guide on twitter"
        href="https://twitter.com/intent/tweet/?text=Sequential%20Testing%20Guide&amp;url=https%3a%2f%2fnpodlozhniy.github.io%2fposts%2fsequential-testing%2f&amp;hashtags=">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Sequential Testing Guide on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fnpodlozhniy.github.io%2fposts%2fsequential-testing%2f&amp;title=Sequential%20Testing%20Guide&amp;summary=Sequential%20Testing%20Guide&amp;source=https%3a%2f%2fnpodlozhniy.github.io%2fposts%2fsequential-testing%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Sequential Testing Guide on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fnpodlozhniy.github.io%2fposts%2fsequential-testing%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Sequential Testing Guide on telegram"
        href="https://telegram.me/share/url?text=Sequential%20Testing%20Guide&amp;url=https%3a%2f%2fnpodlozhniy.github.io%2fposts%2fsequential-testing%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

  </footer><div id="disqus_thread"></div>
<script>
	
    var disqus_config = function () {
    this.page.url = 'https:\/\/npodlozhniy.github.io\/posts\/sequential-testing\/';  
    this.page.identifier = ''; 
	this.language = document.documentElement.lang; 
	};
 
    (function() { 
    var d = document, s = d.createElement('script');
    s.src = 'https://https-npodlozhniy-github-io-2.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();
	
    document.addEventListener('theme-change', function(e) { 
		if (document.readyState == 'complete') {
			DISQUS.reset({ reload: true, config: disqus_config });
		}
	});

</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://npodlozhniy.github.io/">Nikita Podlozhniy</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }

		
		const event = new Event('theme-change');
		document.dispatchEvent(event)
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
